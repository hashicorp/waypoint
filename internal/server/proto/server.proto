syntax = "proto3";

package hashicorp.waypoint;

option go_package = "internal/server/gen";

import "google/protobuf/any.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "google/rpc/status.proto";

// The service that is implemented for the server backend.
service Waypoint {
  // GetVersionInfo returns information about the server. This RPC call does
  // NOT require authentication. It can be used by clients to determine if they
  // are capable of talking to this server.
  rpc GetVersionInfo(google.protobuf.Empty) returns (GetVersionInfoResponse);

  // ListWorkspaces returns a list of all workspaces.
  //
  // Note that currently this list is never pruned, even if a workspace is
  // no longer in use. We plan to prune this in a future improvement.
  rpc ListWorkspaces(google.protobuf.Empty) returns (ListWorkspacesResponse);

  // GetWorkspace returns the workspace.
  rpc GetWorkspace(GetWorkspaceRequest) returns (GetWorkspaceResponse);

  // UpsertProject upserts the project.
  rpc UpsertProject(UpsertProjectRequest) returns (UpsertProjectResponse);

  // GetProject returns the project.
  rpc GetProject(GetProjectRequest) returns (GetProjectResponse);

  // ListProjects returns a list of all the projects. There is no equivalent
  // ListApplications because applications are a part of projects and you
  // can use GetProject to get more information about the project.
  rpc ListProjects(google.protobuf.Empty) returns (ListProjectsResponse);

  // UpsertApplication upserts an application with a project. If the application
  // is already registered this does nothing.
  rpc UpsertApplication(UpsertApplicationRequest) returns (UpsertApplicationResponse);

  // ListBuilds returns the builds.
  rpc ListBuilds(ListBuildsRequest) returns (ListBuildsResponse);

  // GetBuild returns a build
  rpc GetBuild(GetBuildRequest) returns (Build);

  // ListPushedArtifacts returns the builds.
  rpc ListPushedArtifacts(ListPushedArtifactsRequest) returns (ListPushedArtifactsResponse);

  // GetPushedArtifact returns a deployment
  rpc GetPushedArtifact(GetPushedArtifactRequest) returns (PushedArtifact);

  // ListDeployments returns the deployments.
  rpc ListDeployments(ListDeploymentsRequest) returns (ListDeploymentsResponse);

  // ListInstances returns the running instances of deployments.
  rpc ListInstances(ListInstancesRequest) returns (ListInstancesResponse);

  // FindExecInstance returns an instance that can be used for an exec session.
  // This is used by the exec cli command to detect if there is a long running
  // instance to connect to or if a virtual instance should be created by running
  // the plugins exec function.
  rpc FindExecInstance(FindExecInstanceRequest) returns (FindExecInstanceResponse);

  // GetDeployment returns a deployment
  rpc GetDeployment(GetDeploymentRequest) returns (Deployment);

  // GetLatestBuild returns the most recent successfully completed build
  // for an app.
  rpc GetLatestBuild(GetLatestBuildRequest) returns (Build);

  // GetLatestPushedArtifact returns the most recent successfully completed
  // artifact push for an app.
  rpc GetLatestPushedArtifact(GetLatestPushedArtifactRequest) returns (PushedArtifact);

  // ListReleases returns the deployments.
  rpc ListReleases(ListReleasesRequest) returns (ListReleasesResponse);

  // GetRelease returns a deployment
  rpc GetRelease(GetReleaseRequest) returns (Release);

  // GetLatestRelease returns the most recent successfully completed
  // artifact push for an app.
  rpc GetLatestRelease(GetLatestReleaseRequest) returns (Release);

  // GetLogStream reads the log stream for a deployment. This will immediately
  // send a single LogEntry with the lines we have so far. If there are no
  // available lines this will NOT block and instead will return an error.
  // The client can choose to retry or not.
  rpc GetLogStream(GetLogStreamRequest) returns (stream LogBatch);

  // StartExecStream starts an exec session.
  rpc StartExecStream(stream ExecStreamRequest) returns (stream ExecStreamResponse);

  // Set a single configuration item for the application.
  rpc SetConfig(ConfigSetRequest) returns (ConfigSetResponse);

  // Retrieve merged configuration values for a specific scope. You can determine
  // where a configuration variable was set by looking at the scope field on
  // each variable.
  rpc GetConfig(ConfigGetRequest) returns (ConfigGetResponse);

  // Set the configuration for a dynamic configuration source. If you're looking
  // to set application configuration, you probably want SetConfig instead.
  rpc SetConfigSource(SetConfigSourceRequest) returns (google.protobuf.Empty);

  // Get the matching configuration source for the request. This will return
  // the most specific matching config source given the scope in the request.
  // For example, if you search for an app-specific config source and only
  // a global config exists, the global config will be returned.
  rpc GetConfigSource(GetConfigSourceRequest) returns (GetConfigSourceResponse);

  // Create a hostname with the URL service.
  rpc CreateHostname(CreateHostnameRequest) returns (CreateHostnameResponse);

  // Delete a hostname with the URL service.
  rpc DeleteHostname(DeleteHostnameRequest) returns (google.protobuf.Empty);

  // List all our registered hostnames.
  rpc ListHostnames(ListHostnamesRequest) returns (ListHostnamesResponse);

  // QueueJob queues a job for execution by a runner. This will return as
  // soon as the job is queued, it will not wait for execution.
  rpc QueueJob(QueueJobRequest) returns (QueueJobResponse);

  // CancelJob cancels a job. If the job is still queued this is a quick
  // and easy operation. If the job is already completed, then this does
  // nothing. If the job is assigned or running, then this will signal
  // the runner about the cancellation but it may take time.
  //
  // This RPC always returns immediately. You must use GetJob or GetJobStream
  // to wait on the status of the cancellation.
  rpc CancelJob(CancelJobRequest) returns (google.protobuf.Empty);

  // GetJob queries a job by ID.
  rpc GetJob(GetJobRequest) returns (Job);

  // INTERNAL: ListJobs lists all the jobs the server has processed. This
  // is not yet ready for public use.
  rpc _ListJobs(ListJobsRequest) returns (ListJobsResponse);

  // ValidateJob checks if a job appears valid. This will check the job
  // structure itself (i.e. missing fields) and can also check to ensure
  // the job is assignable to a runner.
  rpc ValidateJob(ValidateJobRequest) returns (ValidateJobResponse);

  // GetJobStream opens a job event stream for a running job. This can be
  // used to listen for terminal output and other events of a running job.
  // Multiple listeners can open a job stream.
  rpc GetJobStream(GetJobStreamRequest) returns (stream GetJobStreamResponse);

  // GetRunner gets information about a single runner.
  rpc GetRunner(GetRunnerRequest) returns (Runner);

  // GetServerConfig sets configuration for the Waypoint server.
  rpc GetServerConfig(google.protobuf.Empty) returns (GetServerConfigResponse);

  // SetServerConfig sets configuration for the Waypoint server.
  rpc SetServerConfig(SetServerConfigRequest) returns (google.protobuf.Empty);

  // CreateSnapshot creates a new database snapshot.
  rpc CreateSnapshot(google.protobuf.Empty) returns (stream CreateSnapshotResponse);

  // RestoreSnapshot performs a database restore with the given snapshot.
  // This API doesn't do a full online restore, it only stages the restore
  // for the next server start to finalize the restore. See the arguments for
  // more information.
  rpc RestoreSnapshot(stream RestoreSnapshotRequest) returns (google.protobuf.Empty);

  // BootstrapToken returns the initial token for the server. This can only
  // be requested once on first startup. After initial request this will
  // always return a PermissionDenied error.
  rpc BootstrapToken(google.protobuf.Empty) returns (NewTokenResponse);

  // Generate a new invite token that users can exchange for a login token.
  rpc GenerateInviteToken(InviteTokenRequest) returns (NewTokenResponse);

  // Generate a new login token that users can use to login directly.
  rpc GenerateLoginToken(google.protobuf.Empty) returns (NewTokenResponse);

  // Exchange a invite token for a login token.
  rpc ConvertInviteToken(ConvertInviteTokenRequest) returns (NewTokenResponse);

  //----------------------------------------------------------------------
  // Runner endpoints. These are expected to be called only by a runner.
  // These are not meant to be public endpoints.
  //----------------------------------------------------------------------

  // RunnerConfig is called to register a runner and receive the configuration
  // for the runner. The response is a stream so that the configuration can
  // be updated later.
  rpc RunnerConfig(stream RunnerConfigRequest) returns (stream RunnerConfigResponse);

  // RunnerJobStream is called by a runner to request a single job for
  // execution and update the status of that job.
  rpc RunnerJobStream(stream RunnerJobStreamRequest) returns (stream RunnerJobStreamResponse);

  // RunnerGetDeploymentConfig is called by a runner for a deployment operation
  // to determine the settings to use for a deployment.
  rpc RunnerGetDeploymentConfig(RunnerGetDeploymentConfigRequest) returns (RunnerGetDeploymentConfigResponse);

  //----------------------------------------------------------------------
  // Entrypoint binary endpoints. These are all expected to be called by
  // the entrypoint binary only.
  //----------------------------------------------------------------------

  // EntrypointConfig is called to get the configuration for the entrypoint
  // and also to get any potential updates.
  //
  // This endpoint also registers the instance with the server. This MUST be
  // called first otherwise other RPCs related to the entrypoint may fail
  // with FailedPrecondition.
  rpc EntrypointConfig(EntrypointConfigRequest) returns (stream EntrypointConfigResponse);

  // EntrypointLogStream is called to open the stream that logs are sent to.
  rpc EntrypointLogStream(stream EntrypointLogBatch) returns (google.protobuf.Empty);

  // EntrypointExecStream is called to open the data stream for the exec session.
  rpc EntrypointExecStream(stream EntrypointExecRequest) returns (stream EntrypointExecResponse);

  //----------------------------------------------------------------------
  // Waypoint.hcl functions. These endpoints don't modify any server state,
  // they're conveniences to build tools on top of Waypoint.
  //----------------------------------------------------------------------

  // WaypointHclFmt formats a waypoint.hcl file. This must be in HCL format.
  // JSON formatting is not supported.
  rpc WaypointHclFmt(WaypointHclFmtRequest) returns (WaypointHclFmtResponse);

  //----------------------------------------------------------------------
  // Internal metadata endpoints. The endpoints below are expected to be
  // called for internal bookkeeping only. They should be avoided for general
  // API clients since they can be used to damage internal state.
  //----------------------------------------------------------------------

  // UpsertBuild updates or inserts a build. A build is responsible for
  // taking some set of source information and turning it into an initial
  // artifact. This artifact is considered "local" until it is pushed.
  rpc UpsertBuild(UpsertBuildRequest) returns (UpsertBuildResponse);

  // UpsertPushedArtifact updates or inserts a pushed artifact. This is
  // useful for local operations to work on a pushed artifact.
  rpc UpsertPushedArtifact(UpsertPushedArtifactRequest) returns (UpsertPushedArtifactResponse);

  // UpsertDeployment updates or inserts a deployment.
  rpc UpsertDeployment(UpsertDeploymentRequest) returns (UpsertDeploymentResponse);

  // UpsertRelease updates or inserts a release.
  rpc UpsertRelease(UpsertReleaseRequest) returns (UpsertReleaseResponse);
}

/********************************************************************
* Server Info
********************************************************************/

message GetVersionInfoResponse {
  VersionInfo info = 1;
}

message VersionInfo {
  ProtocolVersion api = 1;
  ProtocolVersion entrypoint = 2;

  // Full version string (semver-syntax). This may be hidden/blank for
  // security purposes so clients should gracefully handle blank values.
  string version = 3;

  message ProtocolVersion {
    uint32 current = 1;
    uint32 minimum = 2;
  }
}

/********************************************************************
* Basic Data Model
********************************************************************/

message Application {
  Ref.Project project = 2;

  string name = 1;
}

message Project {
  string name = 1;

  // The set of applications that are known about this project. Note that
  // this may not exactly represent the project configuration if a user hasn't
  // run `waypoint init` yet.
  //
  // The applications cannot be modified in any Project APIs. You must
  // use the dedicated Application APIs.
  repeated Application applications = 2;

  // If true, then the `-remote` flag or the `waypoint build project/app`
  // syntax can be used with a remote runner. If this is false, then
  // this is not allowed. This is typically configured using the
  // `runner {}` block in the waypoint config.
  bool remote_enabled = 3;

  // Where data is sourced for remote operations. If this isn't set, then
  // there is no default data source and it will be an error if a job is
  // queued for this project without a data source set. This is usually
  // set using the `runner {}` block in the waypoint config.
  Job.DataSource data_source = 4;

  // Polling settings. Polling will trigger a "waypoint up" whenever a
  // new data is detected on the data source. For now, polling is only done
  // on the `default` workspace. A future version of Waypoint will expand
  // polling to other workspaces.
  //
  // Each polling event is tracked as a separate job. You can query the
  // poll operations and their success/failure by using the ListJobs API.
  Poll data_source_poll = 7;

  // The contents of a default waypoint.hcl file. This will be used ONLY IF
  // this project does not have a waypoint.hcl file when an operation is
  // executed. When this is used, local operations can't be run any more
  // since the CLI usually determines the project based on the waypoint.hcl
  // file. The CLI may still be used for remote operations by executing
  // i.e. waypoint up <project>
  bytes waypoint_hcl = 5;
  Format waypoint_hcl_format = 6;

  enum Format {
    HCL = 0; // We assume HCL by default
    JSON = 1;
  }

  message Poll {
    // enabled must be set to true to enable polling.
    bool enabled = 1;

    // interval is a duration string of how often to poll, such as "5s".
    // The server may enforce minimum values, in which case a value lower
    // than the minimum will be ignored.
    string interval = 2;
  }
}

message Workspace {
  // Old fields that were removed.
  reserved 2;
  reserved "applications";

  string name = 1;

  // The list of projects that have executed at least one operation within
  // the context of this workspace.
  repeated Project projects = 4;

  // active_time is the last time that this workspace had activity.
  google.protobuf.Timestamp active_time = 3;

  message Project {
    // Project that this is referencing.
    Ref.Project project = 1;

    // Workspace that this project is part of. This will only be set
    // when using the GetProject API. This will ALWAYS BE NIL on workspace
    // list and get APIs.
    Ref.Workspace workspace = 5;

    // The last non-local ref that was used for any operation.
    Job.DataSource.Ref data_source_ref = 2;

    // active_time is the last time that this project had activity in
    // this workspace.
    google.protobuf.Timestamp active_time = 3;

    // The list of applications that have executed at least one operation
    // within the context of this workspace. To determine which operations
    // you must call the respect list API for that operation, such as
    // ListDeployments.
    repeated Application applications = 4;
  }

  message Application {
    // Application that this is referencing.
    Ref.Application application = 1;

    // active_time is the last time that this application was active
    google.protobuf.Timestamp active_time = 2;
  }
}

/********************************************************************
* Shared Messages
********************************************************************/

// Ref contains shared messages used for references to other resources.
//
// Refs should be used when the full type shouldn't be embedded in the message.
message Ref {
  // Global references the entire server. This is used in some APIs
  // as a way to read/write values that are server-global.
  message Global {}

  // Application references an application. To uniquely identify an
  // application, this must encapsulate the full hierarchy to the application.
  message Application {
    string application = 1;
    string project = 2;
  }

  // Project references a project.
  message Project {
    string project = 1;
  }

  // Workspace references a workspace.
  message Workspace {
    string workspace = 1;
  }

  // Component references a component.
  message Component {
    hashicorp.waypoint.Component.Type type = 1;
    string name = 2;
  }

  // Operation references an operation (build, deploy, etc.). This can reference
  // an operation in multiple ways so you must use the oneof to choose.
  message Operation {
    oneof target {
      string id = 1;
      OperationSeq sequence = 2;
    }
  }

  // OperationSeq references an operation by sequence number.
  message OperationSeq {
    Application application = 1;
    uint64 number = 2;
  }

  // Runner references a runner process which executes operations. This
  // can reference a runner by any of the more specific types, such as
  // by ID. If you want to constrain which runners can be targeted,
  // a different ref type should be used.
  message Runner {
    oneof target {
      RunnerAny any = 1;
      RunnerId id = 2;
    }
  }

  // RunenrId references a runner by ID.
  message RunnerId {
    string id = 1;
  }

  // RunnerAny will reference any runner.
  message RunnerAny {}
}

// Component represents metadata about a component. A component is the
// generic name for a builder, registry, platform, etc.
message Component {
  // type of the component
  Type type = 1;

  // name of the component
  string name = 2;

  // Supported component types, the values here MUST match the enum values
  // in the Go sdk/component package exactly. A test in internal/server
  // validates this.
  enum Type {
    UNKNOWN = 0;
    BUILDER = 1;
    REGISTRY = 2;
    PLATFORM = 3;
    RELEASEMANAGER = 4;
  }
}

// Status represents the status of an async operation.
message Status {
  // state is the state of this operation.
  State state = 1;

  // details may be non-empty to provide human-friendly information
  // about the current status. This may change between status updates
  // for the same state to provide updated details about the state.
  string details = 2;

  // error is set if the state == ERROR with the error that occurred.
  google.rpc.Status error = 3;

  // start_time is the time the operation was started.
  google.protobuf.Timestamp start_time = 4;

  // complete_time is the time the operation completed (success or fail).
  google.protobuf.Timestamp complete_time = 5;

  enum State {
    UNKNOWN = 0;
    RUNNING = 1;
    SUCCESS = 2;
    ERROR = 3;
  }
}

message StatusFilter {
  // Filters are ANDed together.
  repeated Filter filters = 1;

  message Filter {
    oneof filter {
      // state will match any status that has the given state.
      Status.State state = 2;
    }
  }
}

// Operation is a shared message type used to describe "operations" which are
// executions of a build, deploy, etc. This just contains shared message types
// used for fields. Each individual operation has their own message type
// such as Deployment.
message Operation {
  // PhysicalState is the state of any physical resources associated with
  // an operation. A physical resource for example is the actual container
  // that might be created alongside an operation.
  enum PhysicalState {
    UNKNOWN = 0;
    PENDING = 1;
    CREATED = 3;
    DESTROYED = 4;
  };
}

// OperationOrder is a shared message type used for controlling the order
// of results in queries for app operations such as build, deploys, etc.
message OperationOrder {
  // Order for the results.
  Order order = 2;
  bool desc = 3;

  // Limit the number of results
  uint32 limit = 4;

  enum Order {
    UNSET = 0;
    START_TIME = 1;
    COMPLETE_TIME = 2;
  }
}

/********************************************************************
* Queueing
********************************************************************/

message QueueJobRequest {
  // The job to queue. See the Job message documentation for more details
  // on what to set.
  Job job = 1;

  // Set an expiration duration. If the job is not assigned and acked
  // in the given duration then the job will be automatically cancelled.
  string expires_in = 2;
}

message QueueJobResponse {
  // the job ID that was queued. This can be used with other RPC methods
  // to check on the status, cancel, etc.
  string job_id = 1;
}


message CancelJobRequest {
  // The job to cancel
  string job_id = 1;
}

message ValidateJobRequest {
  // The job to validate.
  Job job = 1;

  // If true, will NOT validate that the job is assignable.
  bool disable_assign = 2;
}

message ValidateJobResponse {
  // valid will be true if the job structure is valid. If it is invalid
  // validation_error will be set with a reason.
  bool valid = 1;
  google.rpc.Status validation_error = 2;

  // assignable will be true if the job is assignable at this point-in-time.
  // Assignable means that there are runners registered with the server that
  // claim to be able to service this job. Note that this is a point-in-time
  // result so it doesn't guarantee that a job will be serviced when queued.
  // Additionally, assignability doesn't imply anything about queue length,
  // so the job may still be queued for some time.
  //
  // This will always be false if "valid" is false since we don't check
  // assignability of invalid jobs.
  bool assignable = 3;
}

// A Job is a job that executes on a runner and is queued by QueueOperation.
message Job {
  reserved 64 to 99; // future operation range

  // id of the job. This is generated on the server side when queued. If
  // you are queueing a job, this must be empty or unset.
  string id = 1;

  // If this is set, then only one job with this singleton_id may exist
  // at any point in the QUEUED state. If QueueJob is called with this set
  // and an existing job is already queued with a matching singleton_id,
  // that job will be overwritten with this job.
  string singleton_id = 8;

  // The application to target for the operation. Some operations may allow
  // certain fields of this to be empty, so check with the operation
  // documentation to determine what needs to be set. Generally, project
  // must be set.
  Ref.Application application = 2;

  // The workspace to perform the operation in.
  Ref.Workspace workspace = 3;

  // The runner that should execute this job. This is required.
  Ref.Runner target_runner = 4;

  // Labels are the labels to set for this operation.
  map<string, string> labels = 5;

  // data_source determines where the data to operate on (such as the
  // application source code and Waypoint configuration) comes from.
  // If this is not set then QueueJob will populate this if a default
  // data source is configured for the target project.
  //
  // The overrides will set overrides of configs for the data source. This is
  // data source dependent but this allows for example setting the Git ref
  // without knowing the full data source. Invalid overrides will fail the
  // job.
  DataSource data_source = 6;
  map<string, string> data_source_overrides = 7;

  // The operation to execute. See the message docs for details on the operation.
  oneof operation {
    Noop noop = 50;
    BuildOp build = 51;
    PushOp push = 52;
    DeployOp deploy = 53;
    DestroyOp destroy = 54;
    ReleaseOp release = 55;
    ValidateOp validate = 56;
    AuthOp auth = 57;
    DocsOp docs = 58;
    ConfigSyncOp config_sync = 59;
    ExecOp exec = 60;
    UpOp up = 61;
    PollOp poll = 62;
    QueueProjectOp queue_project = 63;
  }

  //-----------------------------------------------------------------
  // Server-side fields - the fields below are all set by the server
  // and should not be set on the queueing request.
  //-----------------------------------------------------------------

  // state of the job
  State state = 100;

  // The runner that was assigned to execute this job. Note that the
  // runner may have been ephemeral and may no longer exist.
  Ref.RunnerId assigned_runner = 101;

  // The time when the job was queued.
  google.protobuf.Timestamp queue_time = 102;
  google.protobuf.Timestamp assign_time = 103;
  google.protobuf.Timestamp ack_time = 104;
  google.protobuf.Timestamp complete_time = 105;

  // Ref of the data was fetched for this job. This is available after
  // the Ref event is sent down by GetJobStream. This is NOT used to specify
  // the ref that should be downloaded. That level of configuration should be
  // exposed via the data_source parameter itself.
  DataSource.Ref data_source_ref = 110;

  // error is set if state == ERROR
  google.rpc.Status error = 106;

  // result is set based on the operation specified. A nil result is possible
  // for some operations.
  Result result = 107;

  // cancel time is the time that cancellation of this job was requested.
  // If this is zero then this job was not cancelled. Note that this is the
  // cancellation _request_ time. The actual time a job ended is noted by
  // the complete_time field.
  google.protobuf.Timestamp cancel_time = 108;

  // expire time is the time when this job would expire. If this isn't set
  // then this is a non-expiring job. This will remain set even if the job
  // never expired because it was accepted and run. This field can be used
  // to detect that it was configured to expire.
  google.protobuf.Timestamp expire_time = 109;

  enum State {
    UNKNOWN = 0;
    QUEUED = 1; // queued and waiting for assignment
    WAITING = 2; // assigned to a runner, waiting for runner to ack
    RUNNING = 3; // runner acked and is executing
    ERROR = 4; // job failed
    SUCCESS = 5; // job succeeded
  }

  message Result {
    BuildResult build = 1;
    PushResult push = 2;
    DeployResult deploy = 3;
    ReleaseResult release = 4;
    ValidateResult validate = 5;
    AuthResult auth = 6;
    DocsResult docs = 7;
    ConfigSyncResult config_sync = 8;
    UpResult up = 9;
    QueueProjectResult queue_project = 10;
  }

  message DataSource {
    oneof source {
      // local means the runner has access to the data locally and will
      // know what to do. This is primarily only useful if the target_runner
      // is a specific runner and should not be used by any runner unless your
      // runners are configured to have access to the proper data.
      Local local = 1;

      // git will check out the data from a Git repository.
      Git git = 2;
    }

    // Ref is a reference to the exact set of data used by a data source.
    message Ref {
      oneof ref {
        // unknown is set if the ref is not known or not supported, such
        // as for local data sources where we have no way to uniquely identify.
        google.protobuf.Empty unknown = 1;

        // git commit
        Git.Ref git = 2;
      }
    }
  }

  message Local {}

  message Git {
    // url of the repository to clone. Local paths are not allowed.
    string url = 1;

    // a ref to checkout. If this isn't specified, then the default
    // ref that is cloned from the URL above will be used.
    string ref = 2;

    // path is a subdirectory within the checked out repository to
    // go into for the configuration. This must be a relative path
    // and may not contain ".."
    string path = 3;

    // auth is the auth mechanism to use for this data source. This is optional.
    // If this isn't set, then the data source will attempt to clone
    // without setting any explicit auth. This usually picks up machine
    // settings like ssh config files and so on if they exist.
    //
    // Note that any auth settings set here are stored in the server and
    // may NOT be encrypted. If you want increased security, we recommend
    // using auth baked into the machine running Waypoint.
    oneof auth {
      Basic basic = 4;
      SSH ssh = 5;
    }

    // Basic auth
    message Basic {
      // username for authentication. If using access token based auth
      // for something like GitHub, this can be any non-empty string.
      string username = 1;

      // password for authentication. If using access token based auth
      // for GitHub, this should be the access token.
      string password = 2;
    }

    // SSH private key auth
    message SSH {
      // private_key_pem is a PEM-encoded private key.
      bytes private_key_pem = 1;

      // password is an optional password for decoding the private key.
      string password = 2;

      // user is the SSH user to use when cloning. This will default to
      // "git" if not specified.
      string user = 3;
    }

    // Ref is used to populate DataSource.Ref
    message Ref {
      // commit is the full commit hash
      string commit = 1;

      // timestamp is the timestamp of the commit
      google.protobuf.Timestamp timestamp = 2;
    }
  }

  // Noop operations do nothing. This is primarily used for testing.
  // This operation will still download the data from the data source.
  // A noop may be useful outside of testing to verify a runner is
  // executing properly or can access data properly.
  message Noop {}

  // UpOp runs the "waypoint up" logic: it does a build (with push),
  // deploy, and release all in one. The results for each child operation
  // will be set directly on the Release message (i.e. "build" will be
  // populated in addition to "up").
  message UpOp {}

  // UpResult is the result of an UpOp. Because "up" calls other operations,
  // the Result message will set the build, deploy, push, and release results.
  message UpResult {
    // release_url is the equivalent of Release.Url. This is the URL that
    // the release plugin generates directly from the platform. For example,
    // on AWS this might be an ALB addr, on K8S this might be a load balancer
    // addr, etc.
    //
    // This can be empty if the release plugin does not support getting a URL.
    string release_url = 1;

    // app_url is the HashiCorp URL service URL for the entire application.
    // Example: mistakenly-crucial-malamute.waypoint.run. If there are multiple
    // hostnames registered for the application, this always picks the first one.
    //
    // This can be blank if the URL service is disabled or errored.
    string app_url = 2;

    // deploy_url is the HashiCorp URL service URL for this specific deploy.
    // Example: mistakenly-crucial-malamute--v1.waypoint.run. Similar to app_url,
    // if there are multiple registered hostnames for the application, this
    // always picks the first one.
    //
    // This can be blank if the URL service is disabled or errored.
    string deploy_url = 3;
  }

  // ValidateOp validates various aspects of a configuration.
  message ValidateOp {}

  message ValidateResult {}

  // AuthOp is the configuration to authenticate any plugins.
  message AuthOp {
    // if true, auth will only be checked but not attempted. Currently
    // this must ALWAYS be true. Only authentication checking is supported.
    bool check_only = 1;

    // if set, only the component matching this reference will be authed.
    // If this component doesn't exist, an error will be returned. If this is
    // unset, all components wll be authed.
    Ref.Component component = 2;
  }

  message AuthResult {
    // results are the list of components that were checked
    repeated Result results = 1;

    message Result {
      // component that was checked
      Component component = 1;

      // result of the auth check. If the component didn't implement the
      // auth interface this will be set to true. You can check for interface
      // implementation using auth_supported. If auth is attempted, the auth
      // operation will recheck the status and this value will reflect the
      // check post-auth attempt. You can use this to verify if the auth
      // succeeded.
      bool check_result = 2;
      google.rpc.Status check_error = 3;

      // this is true if the component was authenticated using the Auth
      // callback. If false, then no attempt was made to authenticate. This
      // can be on purpose for example if "check_only" is set to true on
      // the op.
      bool auth_completed = 4;
      google.rpc.Status auth_error = 5;

      // auth supported is true if this component implemented the auth
      // interface.
      bool auth_supported = 6;
    }
  }

  message BuildOp {
    // Don't push the build to any configured registry.
    bool disable_push = 1;
  }

  message BuildResult {
    // The resulting build
    Build build = 1;

    // The artifact that was pushed. This will be nil if DisablePush was set.
    PushedArtifact push = 2;
  }

  message PushOp {
    // Build to push
    Build build = 1;
  }

  message PushResult {
    PushedArtifact artifact = 1;
  }

  message DeployOp {
    // Artifact to deploy
    PushedArtifact artifact = 1;
  }

  message DeployResult {
    Deployment deployment = 1;
  }

  // Used to start a platform's exec function within a runner. This is only used
  // there are no long running instances for a deployment and can fail if the
  // platform plugin does not provide an exec function.
  message ExecOp {
    // Id to assign the virtual instance created
    string instance_id = 1;

    // The deployment to create the exec session context. Ie, what
    // application code will be available within the exec session.
    Deployment deployment = 2;
  }

  message ExecResult {}

  message DestroyOp {
    // target is what to destroy in this operation.
    oneof target {
      // workspace will delete the app in the workspace that the job
      // is targeting.
      google.protobuf.Empty workspace = 1;

      Deployment deployment = 2;
    }
  }

  message ReleaseOp {
    Deployment deployment = 1;

    // Prune settings. This will prune the deployments that aren't released.
    // The number to prune is determined based on the configuration.
    bool prune = 2;
  }

  message ReleaseResult {
    Release release = 1;
  }

  message DocsOp {}

  message DocsResult {
    // results are the list of components that were checked
    repeated Result results = 1;

    message Result {
      // component that the docs are for
      Component component = 1;
      Documentation docs = 2;
    }
  }

  message ConfigSyncOp {}

  message ConfigSyncResult {}

  // PollOp triggers a poll action for a project. The job will fail if there
  // is no data source configured for the project.
  //
  // A poll operation can be queued even if a project has polling disabled.
  // If a project has polling enabled, a manually queued poll operation will
  // have no effect on the poll timer or intervals.
  message PollOp {
    // NOTE(mitchellh): In the future I think we could have options here
    // to poll only specific workspaces or the full project or whatever.
    // At the time of writing this, we only support single workspace anyways.
  }

  message PollResult {}

  // QueueProjectOp queues a job for all applications in a project. The
  // applications queued may not directly align with what can be found in
  // ListProjects because the application list will be based on the config
  // and not the database.
  message QueueProjectOp {
    // The template for the job to queue for each application. The "application"
    // field will be overwritten for each application. All other fields are
    // untouched.
    Job job_template = 1;
  }

  message QueueProjectResult {
    // All applications that had jobs queued. This may be empty even if the
    // job was a success. If this is empty, it means that no applications were
    // found to have jobs queued.
    repeated Application applications = 1;

    message Application {
      // Application that was queued.
      Ref.Application application = 1;

      // ID of the job that was queued.
      string job_id = 2;
    }
  }
}

message Documentation {
  string description = 1;
  string example = 2;
  string input = 3;
  string output = 4;
  map<string, Field> fields = 5;
  repeated Mapper mappers = 6;

  message Field {
    string name = 1;
    string synopsis = 2;
    string summary = 3;
    bool optional = 4;
    string env_var = 5;
    string type = 6;
    string default = 7;
  }

  message Mapper {
    string input = 1;
    string output = 2;
    string description = 3;
  }
}


message GetJobRequest {
  // ID of the job to request.
  string job_id = 1;
}

message ListJobsRequest {}

message ListJobsResponse {
  repeated Job jobs = 1;
}

message GetJobStreamRequest {
  string job_id = 1;

  // Future: can add a timestamp here so that only output from after the
  // given timestamp is sent down.
}

message GetJobStreamResponse {
  oneof event {
    // Open is sent as confirmation that the job stream successfully opened.
    // This will be sent immediately by the server if the job ID is valid.
    // This is useful since other events such as terminal output may not
    // happen for a long time while the job is executing, queued, etc.
    //
    // This is ALWAYS sent. If the job is already completed, this will be
    // sent first followed immediately by a Complete.
    Open open = 1;

    // state is sent when there is a job state change event. This event is
    // also used if there is job metadata changes. In this case, the state
    // may be the same but the job is different.
    State state = 2;

    // terminal output. On initial connection, the server may send buffered
    // historical terminal data so there isn't a race between queueing a job
    // and getting its first byte output. You can determine this based on the
    // flag on Terminal.
    Terminal terminal = 3;

    // data downloaded for the job. This is sent after the state is RUNNING
    // when the runner has cloned any data (if necessary) containing information
    // about the data. This is an optional event and may not be sent, indicating
    // that the runner is either older and doesn't support this event or that
    // there was no data download necessary and it is using local data.
    Download download = 6;

    // an error regarding the stream itself, rather than the executing job.
    // For example, if you request a job stream for an invalid job ID,
    // this will be sent back. If this is sent, no further messages will
    // be sent and the stream is terminated.
    //
    // For errors in job execution, see "complete".
    Error error = 4;

    // job completion, no more events will follow this one. This can be
    // both success or failure, the event must be checked. Any errors
    // in complete are errors from the job execution itself.
    Complete complete = 5;
  }

  message Open {}

  message State {
    // previous and current are the previous and current states, respectively.
    Job.State previous = 1;
    Job.State current = 2;

    // The full updated job is also sent because additional fields may be
    // set depending on the state (such as the assigned runner, assignment
    // times, etc.)
    Job job = 3;

    // canceling is true if the job was requested to be canceled.
    bool canceling = 4;
  }

  message Download {
    // The ref for the data that was downloaded. This can be nil if no
    // data was downloaded (though it'd be more reasonable to just not
    // send a download event in that case).
    Job.DataSource.Ref data_source_ref = 1;
  }

  message Terminal {
    repeated Event events = 1;

    // buffered if true signifies that the data being sent is from the
    // server buffer and is historical vs real-time since the stream was
    // opened. If this is true, all lines are buffered. We will never mix
    // buffered and non-buffered lines.
    bool buffered = 2;

    message Event {
      // timestamp of the event as seen by the runner. This might be
      // skewed from the server or the client but relative to all other
      // line output, it will be accurate.
      google.protobuf.Timestamp timestamp = 1;

      oneof event {
        Line line = 2;
        Status status = 3;
        NamedValues named_values = 4;
        Raw raw = 5;
        Table table = 6;
        StepGroup step_group = 7;
        Step step = 8;
      }

      message Status {
        string status = 1;
        string msg = 2;
        bool step = 3;
      }

      message Line {
        string msg = 1;
        string style = 2;
      }

      message Raw {
        bytes data = 1;
        bool stderr = 2;
      }

      message NamedValue {
        string name = 1;
        string value = 2;
      }

      message NamedValues {
        repeated NamedValue values = 1;
      }

      message TableEntry {
        string value = 1;
        string color = 2;
      }

      message TableRow {
        repeated TableEntry entries = 1;
      }

      message Table {
        repeated string headers = 1;
        repeated TableRow rows = 2;
      }

      message StepGroup {
        bool close = 1;
      }

      message Step {
        int32 id = 1;
        bool close = 2;
        string msg = 3;
        string status = 4;
        bytes output = 5;
      }
    }
  }

  message Error {
    google.rpc.Status error = 1;
  }

  message Complete {
    // error, if set, is an error that occurred as part of the job execution
    // and resulted in job termination. This is different than the "error"
    // event which is an error in the stream itself.
    google.rpc.Status error = 1;

    // Result will be set to the final result of the job execution, if any.
    Job.Result result = 2;
  }
}

/********************************************************************
* Runner
********************************************************************/

message Runner {
  // id is a unique ID generated by the runner. This should be a UUID or some
  // other guaranteed unique mechanism. This is not an auth mechanism, just
  // a way to associate an ID to a runner.
  string id = 1;

  // The runner will only be assigned jobs that directly target this
  // runner by ID. This is used by local runners to prevent external
  // jobs from being assigned to them.
  bool by_id_only = 2;

  // Components are the list of components that the runner supports. This
  // is used to match jobs to this runner.
  repeated Component components = 3;
}

message RunnerConfigRequest {
  oneof event {
    Open open = 1;
  }

  message Open {
    // Runner to register. See Runner for what fields can be set.
    Runner runner = 1;
  }
}

message RunnerConfigResponse {
  // config is any updated configuration for the runner.
  RunnerConfig config = 2;
}

message RunnerConfig {
  // The configuration for the runner. Any locally set runner config will
  // take priority in a conflict. This allows operators to setup runners
  // with specific configuration without fear that the server will override
  // them.
  repeated ConfigVar config_vars = 1;
}

message RunnerJobStreamRequest {
  oneof event {
    // request MUST BE the first message sent by a client. This is used to
    // signify that a runner is ready to accept a job. This is only ever
    // sent once. Once a job is complete, the client must terminate the
    // stream and open a new connection.
    Request request = 1;

    // ack is sent to accept a job assignment from the server. This
    // should be sent soon after the job is assigned to avoid the job being
    // reassigned and duplicated.
    Ack ack = 2;

    // complete is sent on job completion. This is only sent if there
    // were no errors, so this signals a successful completion. An erroneous
    // completion is signaled by sending an Error event.
    Complete complete = 3;

    // error is sent when there was an error with job execution (after
    // accept was sent). This signals that the job failed and it cannot
    // be retried. This terminates the job and no other events should be
    // sent.
    Error error = 4;

    // terminal output from the job.
    GetJobStreamResponse.Terminal terminal = 5;

    // download event is sent after the data is downloaded. This is optional.
    // If this isn't sent the job will still remain in the "running" state but
    // download details will not be available.
    GetJobStreamResponse.Download download = 7;

    // heartbeat that the job is still running.
    Heartbeat heartbeat = 6;
  }

  message Request {
    string runner_id = 1;
  }

  message Ack {}

  message Complete {
    Job.Result result = 1;
  }

  message Error {
    google.rpc.Status error = 1;
  }

  message Heartbeat {}
}

message RunnerJobStreamResponse {
  oneof event {
    // assignment is when a job is assigned to this job stream. This
    // will happen ONLY in response to a "Request" message from the client.
    JobAssignment assignment = 1;

    // cancel is sent when a cancel request is made.
    JobCancel cancel = 2;
  }

  message JobAssignment {
    Job job = 1;
  }

  message JobCancel {
    bool force = 1;
  }
}

message RunnerGetDeploymentConfigRequest {}

message RunnerGetDeploymentConfigResponse {
  string server_addr = 1;
  bool server_tls = 2;
  bool server_tls_skip_verify = 3;
}

message GetRunnerRequest {
  // ID of the runner to request.
  string runner_id = 1;
}

/********************************************************************
* Server
********************************************************************/

message SetServerConfigRequest {
  ServerConfig config = 1;
}

message GetServerConfigResponse {
  ServerConfig config = 1;
}

// ServerConfig is the configuration for the server that can be read and
// set online. This differs from the configuration used to start the server
// since some settings can only be set via the file vs. the API.
message ServerConfig {
  // The addresses that are advertised for entrypoints. These define how
  // applications reach back to the server. Currently you may only set
  // EXACTLY ONE address. In the future, we'll support multiple advertise
  // addrs and more controls over which are advertised when.
  repeated AdvertiseAddr advertise_addrs = 1;

  message AdvertiseAddr {
    string addr = 1;
    bool tls = 2;
    bool tls_skip_verify = 3;
  }

  // The platform that the server is currently installed to. This is set
  // through the CLI flag '-platform' on installation.
  string platform = 4;
}

/********************************************************************
* Hostnames
********************************************************************/

message CreateHostnameRequest {
  // hostname to register. This may be empty to autogenerate a hostname.
  string hostname = 1;

  // target determines where the hostname routes to.
  Hostname.Target target = 2;
}

message CreateHostnameResponse {
  // Created hostname
  Hostname hostname = 1;
}

message ListHostnamesRequest {
  // Target if set will only return hostnames matching this target.
  // If unset, all hostnames registered for the account will be returned.
  Hostname.Target target = 1;
}

message ListHostnamesResponse {
  repeated Hostname hostnames = 1;
}

message DeleteHostnameRequest {
  string hostname = 1;
}

message Hostname {
  // hostname alone, such as "fabulous-panda"
  string hostname = 1;

  // fqdn is the fully qualified domain, such as "fabulous-panda.waypoint.run"
  string fqdn = 2;

  // target_labels are the raw label targets given to the URL service.
  // We can't reproduce the richer "Target" structure yet but in the future
  // we may expose that.
  map<string,string> target_labels = 3;

  message Target {
    oneof target {
      TargetApp application = 20;
    }
  }

  // TargetApp targets an application in a specific workspace. With
  // this target type, you can still target specific deployments by
  // appending `--<deployment id>` to the hostname after registration.
  message TargetApp {
    Ref.Application application = 1;
    Ref.Workspace workspace = 2;
  }
}

/********************************************************************
* Workspaces
********************************************************************/

message ListWorkspacesResponse {
  repeated Workspace workspaces = 1;
}

message GetWorkspaceRequest {
  Ref.Workspace workspace = 1;
}

message GetWorkspaceResponse {
  Workspace workspace = 1;
}

/********************************************************************
* Projects & Apps
********************************************************************/

message UpsertProjectRequest {
  // Project to upsert. See the message for what fields to set.
  Project project = 1;
}

message UpsertProjectResponse {
  Project project = 1;
}

message GetProjectRequest {
  Ref.Project project = 1;
}

message GetProjectResponse {
  Project project = 1;

  // The list of workspaces that this project is part of.
  repeated Workspace.Project workspaces = 2;
}

message ListProjectsResponse {
  repeated Ref.Project projects = 1;
}

message UpsertApplicationRequest {
  // project to register the app against
  Ref.Project project = 1;

  // name of the application to register
  string name = 2;
}

message UpsertApplicationResponse {
  Application application = 1;
}

/********************************************************************
* Build
********************************************************************/

message UpsertBuildRequest {
  // Build to upsert. If an ID is not set, this will be an insert operation.
  // If the ID is set, that build is updated. It is an error if an update
  // is requested on a non-existent build.
  Build build = 1;
}

message UpsertBuildResponse {
  Build build = 1;
}

message ListBuildsRequest {
  // The application whose builds to list. This must be set.
  Ref.Application application = 1;

  // The workspace to list builds for. If this isn't set, then all builds
  // for the other filters are listed.
  Ref.Workspace workspace = 2;

  // Specifies the order of results. If this isn't specified, the results
  // are in an undefined order.
  OperationOrder order = 3;
}

message ListBuildsResponse {
  // builds is the list of builds.
  repeated Build builds = 1;
}

message GetLatestBuildRequest {
  Ref.Application application = 1;
  Ref.Workspace workspace = 2;
}

message GetBuildRequest {
  Ref.Operation ref = 1;
}

// Build represents a process of creating an artifact that can be in any state,
// such as complete. A successful complete build produces an artifact.
message Build {
  // The application that this build is part of.
  Ref.Application application = 6;

  // The workspace that this exists in
  Ref.Workspace workspace = 7;

  // The sequence number for this build.
  uint64 sequence = 8;

  // id is the unique ID of the build
  string id = 1;

  // status of the build
  Status status = 2;

  // component is the component that was used for this build
  Component component = 3;

  // artifact is the result of the build if the status.state == SUCCESS
  Artifact artifact = 4;

  // labels are the set of labels that are present on this build.
  map<string,string> labels = 5;

  // template data for HCL variables and template functions, json-encoded
  bytes template_data = 10;

  // ID of the job that created this build. This may be empty.
  string job_id = 9;
}

// Artifact is the result of a build or registry. This is the metadata only.
// The binary contents of an artifact are expected to be stored in a registry.
message Artifact {
  // artifact is the full artifact encoded directly from the component plugin.
  // The receiving end must have access to the component proto files to
  // know how to decode this.
  google.protobuf.Any artifact = 1;
}

/********************************************************************
* Registry
********************************************************************/

message UpsertPushedArtifactRequest {
  // artifact to upsert. If the id in the artifact is empty, then this
  // will be an insert. Otherwise, this will be an update and if the ID
  // isn't found, it will be an error.
  PushedArtifact artifact = 1;
}

message UpsertPushedArtifactResponse {
  // resulting push object, you should replace this with what was sent
  // since the update operation may touch up the input data (i.e. update
  // timestamps)
  PushedArtifact artifact = 1;
}

message GetLatestPushedArtifactRequest {
  // application that this belongs to
  Ref.Application application = 1;

  // workspace for the artifact, any workspace if empty
  Ref.Workspace workspace = 2;
}

message GetPushedArtifactRequest {
  Ref.Operation ref = 1;
}

message ListPushedArtifactsRequest {
  // application that this belongs to
  Ref.Application application = 3;

  // workspace for the results, or all if not set
  Ref.Workspace workspace = 4;

  // The filters to apply to this request. These are ORed, so you should
  // specify multiple filters in the StatusFilter for AND behavior.
  repeated StatusFilter status = 1;

  // Specifies the order of results. If this isn't specified, the results
  // are in an undefined order.
  OperationOrder order = 2;

  // Indicate if the Build value should be returned for each
  // of the artifacts as well.
  bool include_build = 5;
}

message ListPushedArtifactsResponse {
  // artifacts is the list of artifacts.
  repeated PushedArtifact artifacts = 1;
}

message PushedArtifact {
  // application that this belongs to
  Ref.Application application = 7;

  // The workspace that this exists in
  Ref.Workspace workspace = 8;

  // The sequence number for this build.
  uint64 sequence = 9;

  // id is a unique ID for this push
  string id = 1;

  // status of the push operation
  Status status = 2;

  // component that pushed this artifact
  Component component = 3;

  // artifact is the artifact that was a result from the push.
  Artifact artifact = 4;

  // the id of the build that this pushed artifact was sourced from.
  string build_id = 5;

  // labels are the set of labels that are present on this build.
  map<string,string> labels = 6;

  // template data for HCL variables and template functions, json-encoded
  bytes template_data = 12;

  // If include_build was set on the list request, this will include
  // the Build value associated with the given build_id.
  Build build = 10;

  // ID of the job that created this. This may be empty.
  string job_id = 11;
}

/********************************************************************
* Platform
********************************************************************/

message GetDeploymentRequest {
  Ref.Operation ref = 1;

  // Inidicate of the fetched deployments should include additional information
  // about each deployment.
  Deployment.LoadDetails load_details = 2;
}

message UpsertDeploymentRequest {
  // deployment to upsert. If the id in the artifact is empty, then this
  // will be an insert. Otherwise, this will be an update and if the ID
  // isn't found, it will be an error.
  Deployment deployment = 1;

  // auto_hostname will automatically create a hostname for this app if
  // one doesn't already exist. This hostname maps to the entire app/workspace
  // combo, not specifically to this deployment.
  //
  // This is a "tri-state" boolean because if this is unset then we use
  // the configured defaults for the server configuration.
  Tristate auto_hostname = 2;

  enum Tristate {
    UNSET = 0;
    TRUE = 1;
    FALSE = 2;
  };
}

message UpsertDeploymentResponse {
  // resulting object, you should replace this with what was sent in the request
  // since the update operation may touch up the input data (i.e. update
  // timestamps)
  Deployment deployment = 1;
}

message ListDeploymentsRequest {
  // application that this deployment belongs to
  Ref.Application application = 3;

  // workspace that this should belong to. If this is empty, values in
  // all workspaces will be listed.
  Ref.Workspace workspace = 4;

  // The filters to apply to this request. These are ORed, so you should
  // specify multiple filters in the StatusFilter for AND behavior.
  repeated StatusFilter status = 1;

  // The physical state to filter for. If this is zero or unset then no
  // filtering on physical state will be done.
  Operation.PhysicalState physical_state = 5;

  // Specifies the order of results. If this isn't specified, the results
  // are in an undefined order.
  OperationOrder order = 2;

  // Inidicate of the fetched deployments should include additional information
  // about each deployment.
  Deployment.LoadDetails load_details = 6;
}

message ListDeploymentsResponse {
  // deployments is the list of deployments.
  repeated Deployment deployments = 1;
}

message Deployment {
  // application that this deployment belongs to
  Ref.Application application = 8;

  // The workspace that this exists in
  Ref.Workspace workspace = 9;

  // The sequence number for this build.
  uint64 sequence = 10;

  // id is the unique ID for this deployment
  string id = 1;

  // state is the state of this deployment.
  Operation.PhysicalState state = 2;

  // status tracks the status of the most recent operation (creation,
  // destroy, etc. NOTE(mitchellh): I want to separate these out so that
  // you can keep history of the status of multiple operations.
  Status status = 3;

  // component that initiated this deployment
  Component component = 4;

  // ID of the PushedArtifact that was deployed.
  string artifact_id = 5;

  // deployment is the full raw deployment object encoded directly from
  // the plugin. The client must have all the plugins setup to properly
  // decode this.
  google.protobuf.Any deployment = 6;

  // labels are the set of labels that are present on this build.
  map<string,string> labels = 7;

  // template data for HCL variables and template functions, json-encoded
  bytes template_data = 14;

  // ID of the job that created this. This may be empty.
  string job_id = 12;

  // True if this deployment had the environment variables available
  // for the entrypoint to talk to. If this is false, this deployment
  // should not be able to communicate back to the server even if it
  // has the entrypoint available. This means this deployment will not
  // support logs, exec, etc.
  bool has_entrypoint_config = 13;

  enum LoadDetails {
    NONE = 0;
    ARTIFACT = 1;
    BUILD = 2;
  }

  // This is the populated preload data. Most of this data can be retrieved
  // through additional API calls or manually computed, but certain API
  // calls will pre-populate some of these fields for convenience. The exact
  // pre-populated fields depend on the API.
  Preload preload = 11;

  message Preload {
    // Populated when a Deployment is read with LoadDetails set
    // to ARTIFACT or BUILD
    PushedArtifact artifact = 1;

    // Populated when a Deployment is read with LoadDetails set to BUILD
    Build build = 2;

    // The deployment-specific URL from the URL service. This is set on
    // all deployment API calls. This will be empty if the URL service
    // is not enabled or there was an error loading this information.
    string deploy_url = 3;
  }
}

/********************************************************************
* Instances
********************************************************************/

message ListInstancesRequest {
  oneof scope {
    // List instances for a specific deployment.
    string deployment_id = 1;

    // Find all instances for an application
    Application application = 2;
  }

  message Application {
    // Application to query. This must have both a project/app set.
    Ref.Application application = 1;

    // Workspace to filter by. If this isn't set, then all workspaces for
    // the app are returned.
    Ref.Workspace workspace = 2;
  }

  // Time to wait before retrying a request to connect to requested instance
  string wait_timeout = 3;
}

message ListInstancesResponse {
  repeated Instance instances = 1;
}

// An instance is a single running process for a deployment. A deployment
// may have many instances (for example Kubernetes ReplicaSets spawn many pods).
// An instance is only represented if you're using the Waypoint Entrypoint.
// Otherwise, the Waypoint server will never be notified of running instances.
message Instance {
  // id of the instance. This should be globally unique to your Waypoint
  // installation but relies on the entrypoint being well behaved.
  string id = 1;

  // The ID of the deployment that this instance belongs to.
  string deployment_id = 2;

  // application that this instance belongs to
  Ref.Application application = 3;

  // The workspace that this exists in
  Ref.Workspace workspace = 4;

  // Which type of instance this is
  Type type = 5;

  // Instances are one of a these types.
  enum Type {
    // The "traditional" instance type, a process that is running
    // constantly for a long period of time.
    LONG_RUNNING = 0;

    // An instance that was launched in response to a request and will
    // disappear quickly.
    ON_DEMAND = 1;

    // An instance that is not actually running any code, but registers
    // itself as an instance for the purposes of interacting with the
    // exec and logs functionality
    VIRTUAL = 2;
  }
}

message FindExecInstanceRequest {
  // List instances for a specific deployment.
  string deployment_id = 1;

  // Time to wait before retrying a request to connect to requested instance
  string wait_timeout = 3;
}

message FindExecInstanceResponse {
  Instance instance = 1;
}

/********************************************************************
* Release Management
********************************************************************/

message UpsertReleaseRequest {
  // release to upsert. If the id in the artifact is empty, then this
  // will be an insert. Otherwise, this will be an update and if the ID
  // isn't found, it will be an error.
  Release release = 1;
}

message UpsertReleaseResponse {
  // resulting object, you should replace this with what was sent in the request
  // since the update operation may touch up the input data (i.e. update
  // timestamps)
  Release release = 1;
}

message GetLatestReleaseRequest {
  // application that this belongs to
  Ref.Application application = 1;

  // workspace for the artifact, any workspace if empty
  Ref.Workspace workspace = 2;

  // Load additional details about the release. These will become available
  // in the Preload section.
  Release.LoadDetails load_details = 3;
}

message ListReleasesRequest {
  // application that this release belongs to
  Ref.Application application = 3;

  // workspace that this should belong to. If this is empty, values in
  // all workspaces will be listed.
  Ref.Workspace workspace = 4;

  // The filters to apply to this request. These are ORed, so you should
  // specify multiple filters in the StatusFilter for AND behavior.
  repeated StatusFilter status = 1;

  // The physical state to filter for. If this is zero or unset then no
  // filtering on physical state will be done.
  Operation.PhysicalState physical_state = 5;

  // Specifies the order of results. If this isn't specified, the results
  // are in an undefined order.
  OperationOrder order = 2;

  // Load additional details about the release. These will become available
  // in the Preload section.
  Release.LoadDetails load_details = 6;
}

message ListReleasesResponse {
  repeated Release releases = 1;
}

message GetReleaseRequest {
  Ref.Operation ref = 1;

  // Load additional details about the release. These will become available
  // in the Preload section.
  Release.LoadDetails load_details = 2;
}

message Release {
  // application that this release belongs to
  Ref.Application application = 7;

  // The workspace that this exists in
  Ref.Workspace workspace = 8;

  // The sequence number for this build.
  uint64 sequence = 10;

  // id is the unique ID for this release.
  string id = 1;

  // status of the release operation.
  Status status = 2;

  // The physical state of the release resources.
  Operation.PhysicalState state = 11;

  // component managing the release process.
  Component component = 3;

  // release is the raw release object encoded directly from the plugin.
  google.protobuf.Any release = 4;

  // ID of the deployment that is being released.
  string deployment_id = 5;

  // labels are the set of labels that are present on this build.
  map<string,string> labels = 6;

  // template data for HCL variables and template functions, json-encoded
  bytes template_data = 14;

  // URL for this release. This is valid while the release is still
  // in use. After the release is not in use, this may still be set but
  // may no longer be valid.
  string url = 9;

  // ID of the job that created this. This may be empty.
  string job_id = 13;

  // This is the populated preload data. Most of this data can be retrieved
  // through additional API calls or manually computed, but certain API
  // calls will pre-populate some of these fields for convenience. The exact
  // pre-populated fields depend on the API.
  Preload preload = 12;

  enum LoadDetails {
    NONE = 0;
    DEPLOYMENT = 1;
    ARTIFACT = 2;
    BUILD = 3;
  }

  message Preload {
    // Populated when LoadDetails is set.
    Deployment deployment = 1;

    // Populated when LoadDetails is set.
    PushedArtifact artifact = 2;

    // Populated when LoadDetails is set.
    Build build = 3;
  }
}

/********************************************************************
* Logs
********************************************************************/

message GetLogStreamRequest {
  oneof scope {
    // Deployment to request logs for.
    string deployment_id = 1;

    // Logs for a specific application in a workspace.
    Application application = 2;
  }

  // limit_backlog sets the maximum backlog lines to return on the initial
  // connection. This setting is per instance, not global. The maximum
  // backlog to expect is `n * limit_backlog` where n is the number of
  // instances.
  //
  // A negative value will not limit the backlog.
  //
  // A value of zero will default to a value of 50.
  int32 limit_backlog = 3;

  message Application {
    Ref.Application application = 1;
    Ref.Workspace workspace = 2;
  }
}

message LogBatch {
  string deployment_id = 1;
  string instance_id = 2;
  repeated Entry lines = 3;

  message Entry {
    Source source = 3;
    google.protobuf.Timestamp timestamp = 1;
    string line = 2;

    enum Source {
      // App is zero for backwards compatibility since Source was
      // added later this allows the default to just work.
      APP = 0;

      // Entrypoint logs.
      ENTRYPOINT = 1;
    }
  }
}

/********************************************************************
* Config
********************************************************************/

message ConfigVar {
  // scope is the scoping for this config variable.
  oneof scope {
    Ref.Application application = 3;
    Ref.Project project = 4;

    // This specifies that the configuration variable is for runners only.
    // You can use more complex runner targeting via this ref.
    Ref.Runner runner = 5;
  }

  // name is the name of the environment variable that this config var is setting
  string name = 1;

  oneof value {
    // unset, if set, unsets this value. For historical reasons, empty static
    // values also unset the value.
    google.protobuf.Empty unset = 7;

    // static, direct value.
    string static = 2;

    // dynamically sourced value
    DynamicVal dynamic = 6;
  }

  // DynamicVal is the configuration for dynamic values for configuration.
  message DynamicVal {
    // from is the config source plugin to use
    string from = 1;

    // config is the configuration for the config source plugin that
    // defines how the value is read. For example, for a "Vault" config
    // source this may contain the path in the KV store to read the value.
    map<string, string> config = 2;
  }
}

message ConfigSetRequest {
  repeated ConfigVar variables = 1;
}

message ConfigSetResponse {}

message ConfigGetRequest {
  // scope is the scoping for this config variable.
  oneof scope {
    Ref.Application application = 2;
    Ref.Project project = 3;
    Ref.RunnerId runner = 4;
  }

  // Get all configuration entries under the given prefix. When empty,
  // returns all config variables.
  string prefix = 1;
}

message ConfigGetResponse {
  repeated ConfigVar variables = 1;
}

/********************************************************************
* Config Sources
********************************************************************/

message ConfigSource {
  // delete may be set to true on SetConfigSource to delete this config source.
  // This is a field on ConfigSource since there are a variety of ways to
  // identify a ConfigSource. Therefore, the recommend deletion process is
  // to query the ConfigSource using GetConfigSource and then set delete
  // on a return value to ensure the correct value is deleted.
  bool delete = 3;

  // Scope that this configuration is valid. Note that this doesn't
  // prevent a config source from being used in other scopes, it only
  // prevents this configuration. Configuration sources used in other
  // scopes will use a default configuration set by the plugin.
  oneof scope {
    Ref.Global global = 50;
  }

  // type of the config source. This should match the plugin name.
  string type = 1;

  // config is the configuration for the config source.
  map<string, string> config = 2;

  // hash is set automatically on write and available on read and is a
  // content hash of the configuration. This can be used to determine
  // uniqueness or changes in the configuration. Setting this value with
  // SetConfigSource has no effect and will be overwritten. Note that this
  // hash may take more into account than just "config" as other fields
  // are introduced to this message type.
  uint64 hash = 4;
}

message SetConfigSourceRequest {
  ConfigSource config_source = 1;
}

message GetConfigSourceRequest {
  // scope is the scoping for the config source.
  oneof scope {
    Ref.Global global = 50;
  }

  // config source type. This is optional. If this is omitted, all
  // config source types matching the above scoping will be returned.
  // This is a prefix-search. All config sources with this type prefix
  // will be returned.
  string type = 1;
}

message GetConfigSourceResponse {
  repeated ConfigSource config_sources = 1;
}

/********************************************************************
* Exec
********************************************************************/

message ExecStreamRequest {
  oneof event {
    Start start = 1;
    Input input = 2;
    WindowSize winch = 3;

    // input_eof should be sent as an event when the input stream is
    // closed. After this, no more Input messages can be sent. Any Input
    // messages sent will be ignored. This will send an EOF on the remote
    // end as well to close stdin for the exec process.
    google.protobuf.Empty input_eof = 4;
  }

  message Start {
    oneof target {
      // Deployment to exec into
      string deployment_id = 1;

      // Instance to send the exec request to. This is indicates that
      // the client wants an exec session to this specific instance,
      // rather than one the server picks. Targetted instances can be
      // any instance type, where as untargeted have to be LONG_RUNNING.
      string instance_id = 4;
    }

    // Args including the command at args[0] to execute.
    repeated string args = 2;

    // Pty is set if we should allocate a PTY for this exec stream.
    PTY pty = 3;
  }

  message Input {
    bytes data = 1;
  }

  message PTY {
    bool enable = 1;

    // term is the TERM value to request on the remote side. This should be set.
    string term = 2;

    // window_size is the initial window size
    WindowSize window_size = 3;
  }

  message WindowSize {
    int32 rows = 1;
    int32 cols = 2;
    int32 width = 3;
    int32 height = 4;
  }
}

message ExecStreamResponse {
  oneof event {
    // Open is always sent first no matter what (unless there is an error
    // in which case the stream will exit). This should be used to validate
    // that the exec process started properly.
    Open open = 3;

    Output output = 1;
    Exit exit = 2;
  }

  message Open {}

  message Exit {
    int32 code = 1;
  }

  message Output {
    Channel channel = 1;
    bytes data = 2;

    enum Channel {
      UNKNOWN = 0;
      STDOUT  = 1;
      STDERR  = 2;
    }
  }
}

/********************************************************************
* Entrypoint
********************************************************************/

message EntrypointConfigRequest {
  // id of the deployment that this instance is a part of
  string deployment_id = 1;

  // instance_id is a unique ID generated by the running entrypoint. This is
  // not an auth mechanism, just a way to associate data with the correct instance.
  string instance_id = 2;

  // The type of instance that is making the config request. This type will be
  // recorded by the server to alter how the server interacts with the instance.
  Instance.Type type = 3;
}

message EntrypointConfigResponse {
  EntrypointConfig config = 2;
}

message EntrypointConfig {
  // Exec are requested exec sessions for this instance.
  repeated Exec exec = 1;

  // The environment variables to set in the entrypoint.
  repeated ConfigVar env_vars = 2;

  // The configuration for any config sources that may be used in the
  // config vars sent down. The server may send down extra configs that
  // aren't used so consumers should filter these based on what env vars
  // are actually in use.
  repeated ConfigSource config_sources = 5;

  // The URL service configuration. This might be nil. If this is nil,
  // then the URL service is disabled.
  URLService url_service = 3;

  // Deployment is the deployment information for this instance. This may
  // be nil if the user is running an old enough server so always nil-check this.
  DeploymentInfo deployment = 4;

  message Exec {
    int64 index = 1;
    repeated string args = 2;
    ExecStreamRequest.PTY pty = 3;
  }

  message URLService {
    // address to the control server and the token for auth
    string control_addr = 1;
    string token = 2;

    // labels to register this instance under
    string labels = 3;
  }

  message DeploymentInfo {
    // component is the deployment plugin information that launched this instance.
    Component component = 1;

    // labels are the set of labels that are present on the deployment.
    map<string,string> labels = 2;
  }
}

// A batch of data for log streaming from the entrypoint.
message EntrypointLogBatch {
  // instance_id is a unique ID generated by the running entrypoint. This is
  // not an auth mechanism, just a way to associate data with the correct instance.
  string instance_id = 1;

  // lines is the set of lines
  repeated LogBatch.Entry lines = 2;
}

message EntrypointExecRequest {
  oneof event {
    // open MUST BE the first message sent by a client. This will be used
    // by the server side to perform some initialization. If the first message
    // is not open the server will close the connection.
    Open open = 1;

    // exit should be sent as a final message type after the command exits.
    Exit exit = 2;

    // output contains stdout/stderr
    Output output = 3;

    // error indicates an error occurred. This will terminate the stream.
    Error error = 4;
  }

  message Open {
    string instance_id = 1;
    int64 index = 2;
  }

  message Exit {
    int32 code = 1;
  }

  message Output {
    Channel channel = 1;
    bytes data = 2;

    enum Channel {
      UNKNOWN = 0;
      STDOUT  = 1;
      STDERR  = 2;
    }
  }

  message Error {
    google.rpc.Status error = 1;
  }
}

message EntrypointExecResponse {
  oneof event {
    // input is raw stdin input from the client
    bytes input = 1;

    // input_eof means that stdin is now closed
    google.protobuf.Empty input_eof = 4;

    // winch is SIGWNCH information for window sizing
    ExecStreamRequest.WindowSize winch = 2;

    // opened is sent when the entrypoint session is successfully opened.
    // The value of this message is meaningless. The existence of the message
    // itself is a signal that the stream was opened properly.
    bool opened = 3;
  }
}

/********************************************************************
* Token
********************************************************************/

// The outer structure of the token that is directly Marshaled and
// ASCII armored.
message TokenTransport {
  // A Marshaled token, stored as bytes because we need to to validate
  // it with the given signature.
  bytes body = 1;

  // The signature of body for validation.
  bytes signature = 2;

  // The key used to generate the signature.
  string key_id = 3;

  // Any configuration style metadata that can be passed along with the token
  // without invalidating the token body itself.
  map<string, string> metadata = 4;
}

// The authenticated Token information. This is used to authenticate requests.
message Token {
  // The user that the token is fore.
  string user = 1;

  // A random id for the token. Also functions as a nonce when signing.
  bytes token_id = 2;

  // When the token is valid until. After the given date, the token will be rejected.
  // When this is not set, the token is valid forever.
  google.protobuf.Timestamp valid_until = 3;

  // Indicates whether or not this token can be used for to authenticate RPCs.
  bool login = 4;

  // Inidicates whether or not this token can be used as an invite.
  bool invite = 5;

  // Entrypoint if set indicates that this token is for entrypoint binary
  // usage only and specific restrictions are specified in this message.
  Entrypoint entrypoint = 6;

  message Entrypoint {
    // deployment id is the deployment to restrict this token to.
    string deployment_id = 1;
  }
}

// Represents a key used to sign tokens using HMAC
message HMACKey {
  // The identifier of the key.
  string id = 1;

  // A randomly generated key used to sign tokens with
  bytes key = 2;
}

// Passed with GenerateInviteToken with the params on how the invite token should
// be generate.
message InviteTokenRequest {
  // How long the token should be valid until. The resulting token has a timestamp
  // encoded within it by adding the current time to this duration.
  string duration = 1;

  // If set, the token generated by this invite code is for the given entrypoint.
  Token.Entrypoint entrypoint = 2;
}

// Returned by any action that creates a token.
message NewTokenResponse {
  // The new token which can be presented to whichever API expects it.
  string token = 1;
}

// Passed to ConvertInviteToken to create a new token that can be used to authenticate RPCs.
message ConvertInviteTokenRequest {
  // A token previous returned by GenerateInviteToken.
  string token = 1;
}

/********************************************************************
* Snapshot/Restore
********************************************************************/

message CreateSnapshotResponse {
  oneof event {
    // Open is sent as the opening message with information about the
    // snapshot. This is always sent first (before any data).
    Open open = 1;

    // Chunk is a next chunk of data. You should continue to expect
    // data until an EOF is received on the stream.
    bytes chunk = 2;
  }

  // One day we may add information here. For now we are reserving this.
  message Open {}
}

message RestoreSnapshotRequest {
  oneof event {
    // Open MUST be sent as the first message and sent exactly once.
    // This sets the settings for the restore.
    Open open = 1;

    // Chunk is a chunk of restore data. The restore snapshot API will
    // continue reading data until an EOF is received (the write end is
    // closed).
    bytes chunk = 2;
  }

  message Open {
    // If true, the server will exit after the restore is staged. This will
    // SHUT DOWN the server and some external process you created is expected
    // to bring it back. The Waypoint server on its own WILL NOT automatically
    // restart. You should only set this if you have some operation to
    // automate restart such as running in Nomad or Kubernetes.
    bool exit = 1;
  }
}

// Snapshot is the encoding of the snapshot for all snapshot APIs.
// The encoding is proto.Message delimited data. This is also the encoding
// expected if the waypoint-restore.db file is copied manually from the
// snapshot data.
//
// For snapshots, the Header message is always guaranteed first. After that,
// it is NOT guaranteed that only data chunks are sent. It is only guaranteed
// that the data chunks are over at EOF. Unknown messages can probably be
// ignored.
//
// It is HIGHLY RECOMMENDED you do not modify snapshots, but these messages
// are publicly exported so that you can try to inspect snapshots.
message Snapshot {
  // Header is _always_ the first message encoded into a snapshot. If
  // this isn't present, the entire snapshot can be considered corrupt.
  message Header {
    // version is the version of Waypoint that generated this snapshot.
    VersionInfo version = 1;

    // format is the format of the remaining messages. This can be used
    // to determine what messages to expect following the header.
    Format format = 2;

    enum Format {
      UNKNOWN = 0;
      BOLT = 1; // Expect a series of BoltChunk messages
    }
  }

  // Trailer is sent as the final message encoded into a snapshot. Detecting
  // when the trailer is is dependent on the format.
  message Trailer {
    // checksum is the checksum of all the bytes up to but not including
    // this proto message. The checksum is for the raw uncompressed bytes.
    oneof checksum {
      string sha256 = 1; // SHA-256 checksum
    }
  }

  // BoltChunk is a single chunk of data for BoltDB if the snapshot format
  // is BOLT. A chunk will always contain items designated for a single bucket,
  // but a bucket may be repeated multiple time across chunks if there are
  // too many items in the bucket.
  //
  // The final BoltChunk will have trailer set to true. Immediaetly following
  // that chunk will be the Trailer message.
  message BoltChunk {
    // bucket is the name of the bucket. This may be empty. If this is empty,
    // then this chunk should be ignored.
    string bucket = 1;

    // items is a id/value mapping of all this chunk of items in this bucket
    map<string, bytes> items = 2;

    // final is true if this is the last bolt chunk being written.
    bool final = 3;
  }
}

/********************************************************************
* Waypoint.hcl Helpers
********************************************************************/

message WaypointHclFmtRequest {
  bytes waypoint_hcl = 1;
}

message WaypointHclFmtResponse {
  bytes waypoint_hcl = 1;
}
