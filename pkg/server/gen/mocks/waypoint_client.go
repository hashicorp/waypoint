// Code generated by mockery v2.15.0. DO NOT EDIT.

package mocks

import (
	context "context"

	gen "github.com/hashicorp/waypoint/pkg/server/gen"
	emptypb "google.golang.org/protobuf/types/known/emptypb"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"
)

// WaypointClient is an autogenerated mock type for the WaypointClient type
type WaypointClient struct {
	mock.Mock
}

// AdoptRunner provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) AdoptRunner(ctx context.Context, in *gen.AdoptRunnerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *gen.AdoptRunnerRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.AdoptRunnerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BootstrapToken provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) BootstrapToken(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*gen.NewTokenResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.NewTokenResponse
	if rf, ok := ret.Get(0).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) *gen.NewTokenResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.NewTokenResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelJob provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) CancelJob(ctx context.Context, in *gen.CancelJobRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *gen.CancelJobRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.CancelJobRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelTask provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) CancelTask(ctx context.Context, in *gen.CancelTaskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *gen.CancelTaskRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.CancelTaskRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CompleteOIDCAuth provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) CompleteOIDCAuth(ctx context.Context, in *gen.CompleteOIDCAuthRequest, opts ...grpc.CallOption) (*gen.CompleteOIDCAuthResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.CompleteOIDCAuthResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.CompleteOIDCAuthRequest, ...grpc.CallOption) *gen.CompleteOIDCAuthResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.CompleteOIDCAuthResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.CompleteOIDCAuthRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConfigSyncPipeline provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ConfigSyncPipeline(ctx context.Context, in *gen.ConfigSyncPipelineRequest, opts ...grpc.CallOption) (*gen.ConfigSyncPipelineResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ConfigSyncPipelineResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ConfigSyncPipelineRequest, ...grpc.CallOption) *gen.ConfigSyncPipelineResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ConfigSyncPipelineResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ConfigSyncPipelineRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConvertInviteToken provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ConvertInviteToken(ctx context.Context, in *gen.ConvertInviteTokenRequest, opts ...grpc.CallOption) (*gen.NewTokenResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.NewTokenResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ConvertInviteTokenRequest, ...grpc.CallOption) *gen.NewTokenResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.NewTokenResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ConvertInviteTokenRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateHostname provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) CreateHostname(ctx context.Context, in *gen.CreateHostnameRequest, opts ...grpc.CallOption) (*gen.CreateHostnameResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.CreateHostnameResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.CreateHostnameRequest, ...grpc.CallOption) *gen.CreateHostnameResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.CreateHostnameResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.CreateHostnameRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProjectFromTemplate provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) CreateProjectFromTemplate(ctx context.Context, in *gen.CreateProjectFromTemplateRequest, opts ...grpc.CallOption) (*gen.CreateProjectFromTemplateResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.CreateProjectFromTemplateResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.CreateProjectFromTemplateRequest, ...grpc.CallOption) *gen.CreateProjectFromTemplateResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.CreateProjectFromTemplateResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.CreateProjectFromTemplateRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProjectTemplate provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) CreateProjectTemplate(ctx context.Context, in *gen.CreateProjectTemplateRequest, opts ...grpc.CallOption) (*gen.CreateProjectTemplateResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.CreateProjectTemplateResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.CreateProjectTemplateRequest, ...grpc.CallOption) *gen.CreateProjectTemplateResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.CreateProjectTemplateResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.CreateProjectTemplateRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSnapshot provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) CreateSnapshot(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (gen.Waypoint_CreateSnapshotClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 gen.Waypoint_CreateSnapshotClient
	if rf, ok := ret.Get(0).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) gen.Waypoint_CreateSnapshotClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Waypoint_CreateSnapshotClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DecodeToken provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) DecodeToken(ctx context.Context, in *gen.DecodeTokenRequest, opts ...grpc.CallOption) (*gen.DecodeTokenResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.DecodeTokenResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.DecodeTokenRequest, ...grpc.CallOption) *gen.DecodeTokenResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.DecodeTokenResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.DecodeTokenRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAuthMethod provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) DeleteAuthMethod(ctx context.Context, in *gen.DeleteAuthMethodRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *gen.DeleteAuthMethodRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.DeleteAuthMethodRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteHostname provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) DeleteHostname(ctx context.Context, in *gen.DeleteHostnameRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *gen.DeleteHostnameRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.DeleteHostnameRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteOnDemandRunnerConfig provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) DeleteOnDemandRunnerConfig(ctx context.Context, in *gen.DeleteOnDemandRunnerConfigRequest, opts ...grpc.CallOption) (*gen.DeleteOnDemandRunnerConfigResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.DeleteOnDemandRunnerConfigResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.DeleteOnDemandRunnerConfigRequest, ...grpc.CallOption) *gen.DeleteOnDemandRunnerConfigResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.DeleteOnDemandRunnerConfigResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.DeleteOnDemandRunnerConfigRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteProjectTemplate provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) DeleteProjectTemplate(ctx context.Context, in *gen.DeleteProjectTemplateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *gen.DeleteProjectTemplateRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.DeleteProjectTemplateRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrigger provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) DeleteTrigger(ctx context.Context, in *gen.DeleteTriggerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *gen.DeleteTriggerRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.DeleteTriggerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUser provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) DeleteUser(ctx context.Context, in *gen.DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *gen.DeleteUserRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.DeleteUserRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DestroyProject provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) DestroyProject(ctx context.Context, in *gen.DestroyProjectRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *gen.DestroyProjectRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.DestroyProjectRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EntrypointConfig provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) EntrypointConfig(ctx context.Context, in *gen.EntrypointConfigRequest, opts ...grpc.CallOption) (gen.Waypoint_EntrypointConfigClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 gen.Waypoint_EntrypointConfigClient
	if rf, ok := ret.Get(0).(func(context.Context, *gen.EntrypointConfigRequest, ...grpc.CallOption) gen.Waypoint_EntrypointConfigClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Waypoint_EntrypointConfigClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.EntrypointConfigRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EntrypointExecStream provides a mock function with given fields: ctx, opts
func (_m *WaypointClient) EntrypointExecStream(ctx context.Context, opts ...grpc.CallOption) (gen.Waypoint_EntrypointExecStreamClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 gen.Waypoint_EntrypointExecStreamClient
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) gen.Waypoint_EntrypointExecStreamClient); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Waypoint_EntrypointExecStreamClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EntrypointLogStream provides a mock function with given fields: ctx, opts
func (_m *WaypointClient) EntrypointLogStream(ctx context.Context, opts ...grpc.CallOption) (gen.Waypoint_EntrypointLogStreamClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 gen.Waypoint_EntrypointLogStreamClient
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) gen.Waypoint_EntrypointLogStreamClient); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Waypoint_EntrypointLogStreamClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExpediteStatusReport provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ExpediteStatusReport(ctx context.Context, in *gen.ExpediteStatusReportRequest, opts ...grpc.CallOption) (*gen.ExpediteStatusReportResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ExpediteStatusReportResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ExpediteStatusReportRequest, ...grpc.CallOption) *gen.ExpediteStatusReportResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ExpediteStatusReportResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ExpediteStatusReportRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ForgetRunner provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ForgetRunner(ctx context.Context, in *gen.ForgetRunnerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ForgetRunnerRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ForgetRunnerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateInviteToken provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GenerateInviteToken(ctx context.Context, in *gen.InviteTokenRequest, opts ...grpc.CallOption) (*gen.NewTokenResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.NewTokenResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.InviteTokenRequest, ...grpc.CallOption) *gen.NewTokenResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.NewTokenResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.InviteTokenRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateLoginToken provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GenerateLoginToken(ctx context.Context, in *gen.LoginTokenRequest, opts ...grpc.CallOption) (*gen.NewTokenResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.NewTokenResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.LoginTokenRequest, ...grpc.CallOption) *gen.NewTokenResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.NewTokenResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.LoginTokenRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateRunnerToken provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GenerateRunnerToken(ctx context.Context, in *gen.GenerateRunnerTokenRequest, opts ...grpc.CallOption) (*gen.NewTokenResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.NewTokenResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GenerateRunnerTokenRequest, ...grpc.CallOption) *gen.NewTokenResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.NewTokenResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GenerateRunnerTokenRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetApplication provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetApplication(ctx context.Context, in *gen.GetApplicationRequest, opts ...grpc.CallOption) (*gen.GetApplicationResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetApplicationResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetApplicationRequest, ...grpc.CallOption) *gen.GetApplicationResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetApplicationResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetApplicationRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAuthMethod provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetAuthMethod(ctx context.Context, in *gen.GetAuthMethodRequest, opts ...grpc.CallOption) (*gen.GetAuthMethodResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetAuthMethodResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetAuthMethodRequest, ...grpc.CallOption) *gen.GetAuthMethodResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetAuthMethodResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetAuthMethodRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBuild provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetBuild(ctx context.Context, in *gen.GetBuildRequest, opts ...grpc.CallOption) (*gen.Build, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.Build
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetBuildRequest, ...grpc.CallOption) *gen.Build); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.Build)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetBuildRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfig provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetConfig(ctx context.Context, in *gen.ConfigGetRequest, opts ...grpc.CallOption) (*gen.ConfigGetResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ConfigGetResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ConfigGetRequest, ...grpc.CallOption) *gen.ConfigGetResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ConfigGetResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ConfigGetRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfigSource provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetConfigSource(ctx context.Context, in *gen.GetConfigSourceRequest, opts ...grpc.CallOption) (*gen.GetConfigSourceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetConfigSourceResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetConfigSourceRequest, ...grpc.CallOption) *gen.GetConfigSourceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetConfigSourceResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetConfigSourceRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDefaultOnDemandRunnerConfig provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetDefaultOnDemandRunnerConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*gen.GetOnDemandRunnerConfigResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetOnDemandRunnerConfigResponse
	if rf, ok := ret.Get(0).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) *gen.GetOnDemandRunnerConfigResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetOnDemandRunnerConfigResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDeployment provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetDeployment(ctx context.Context, in *gen.GetDeploymentRequest, opts ...grpc.CallOption) (*gen.Deployment, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.Deployment
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetDeploymentRequest, ...grpc.CallOption) *gen.Deployment); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.Deployment)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetDeploymentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJob provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetJob(ctx context.Context, in *gen.GetJobRequest, opts ...grpc.CallOption) (*gen.Job, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.Job
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetJobRequest, ...grpc.CallOption) *gen.Job); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.Job)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetJobRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobStream provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetJobStream(ctx context.Context, in *gen.GetJobStreamRequest, opts ...grpc.CallOption) (gen.Waypoint_GetJobStreamClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 gen.Waypoint_GetJobStreamClient
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetJobStreamRequest, ...grpc.CallOption) gen.Waypoint_GetJobStreamClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Waypoint_GetJobStreamClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetJobStreamRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestBuild provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetLatestBuild(ctx context.Context, in *gen.GetLatestBuildRequest, opts ...grpc.CallOption) (*gen.Build, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.Build
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetLatestBuildRequest, ...grpc.CallOption) *gen.Build); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.Build)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetLatestBuildRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestPipelineRun provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetLatestPipelineRun(ctx context.Context, in *gen.GetPipelineRequest, opts ...grpc.CallOption) (*gen.GetPipelineRunResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetPipelineRunResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetPipelineRequest, ...grpc.CallOption) *gen.GetPipelineRunResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetPipelineRunResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetPipelineRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestPushedArtifact provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetLatestPushedArtifact(ctx context.Context, in *gen.GetLatestPushedArtifactRequest, opts ...grpc.CallOption) (*gen.PushedArtifact, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.PushedArtifact
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetLatestPushedArtifactRequest, ...grpc.CallOption) *gen.PushedArtifact); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.PushedArtifact)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetLatestPushedArtifactRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestRelease provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetLatestRelease(ctx context.Context, in *gen.GetLatestReleaseRequest, opts ...grpc.CallOption) (*gen.Release, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.Release
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetLatestReleaseRequest, ...grpc.CallOption) *gen.Release); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.Release)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetLatestReleaseRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestStatusReport provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetLatestStatusReport(ctx context.Context, in *gen.GetLatestStatusReportRequest, opts ...grpc.CallOption) (*gen.StatusReport, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.StatusReport
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetLatestStatusReportRequest, ...grpc.CallOption) *gen.StatusReport); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.StatusReport)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetLatestStatusReportRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLogStream provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetLogStream(ctx context.Context, in *gen.GetLogStreamRequest, opts ...grpc.CallOption) (gen.Waypoint_GetLogStreamClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 gen.Waypoint_GetLogStreamClient
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetLogStreamRequest, ...grpc.CallOption) gen.Waypoint_GetLogStreamClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Waypoint_GetLogStreamClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetLogStreamRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOIDCAuthURL provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetOIDCAuthURL(ctx context.Context, in *gen.GetOIDCAuthURLRequest, opts ...grpc.CallOption) (*gen.GetOIDCAuthURLResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetOIDCAuthURLResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetOIDCAuthURLRequest, ...grpc.CallOption) *gen.GetOIDCAuthURLResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetOIDCAuthURLResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetOIDCAuthURLRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOnDemandRunnerConfig provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetOnDemandRunnerConfig(ctx context.Context, in *gen.GetOnDemandRunnerConfigRequest, opts ...grpc.CallOption) (*gen.GetOnDemandRunnerConfigResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetOnDemandRunnerConfigResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetOnDemandRunnerConfigRequest, ...grpc.CallOption) *gen.GetOnDemandRunnerConfigResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetOnDemandRunnerConfigResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetOnDemandRunnerConfigRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPipeline provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetPipeline(ctx context.Context, in *gen.GetPipelineRequest, opts ...grpc.CallOption) (*gen.GetPipelineResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetPipelineResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetPipelineRequest, ...grpc.CallOption) *gen.GetPipelineResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetPipelineResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetPipelineRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPipelineRun provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetPipelineRun(ctx context.Context, in *gen.GetPipelineRunRequest, opts ...grpc.CallOption) (*gen.GetPipelineRunResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetPipelineRunResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetPipelineRunRequest, ...grpc.CallOption) *gen.GetPipelineRunResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetPipelineRunResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetPipelineRunRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProject provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetProject(ctx context.Context, in *gen.GetProjectRequest, opts ...grpc.CallOption) (*gen.GetProjectResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetProjectResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetProjectRequest, ...grpc.CallOption) *gen.GetProjectResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetProjectResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetProjectRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProjectTemplate provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetProjectTemplate(ctx context.Context, in *gen.GetProjectTemplateRequest, opts ...grpc.CallOption) (*gen.GetProjectTemplateResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetProjectTemplateResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetProjectTemplateRequest, ...grpc.CallOption) *gen.GetProjectTemplateResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetProjectTemplateResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetProjectTemplateRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPushedArtifact provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetPushedArtifact(ctx context.Context, in *gen.GetPushedArtifactRequest, opts ...grpc.CallOption) (*gen.PushedArtifact, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.PushedArtifact
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetPushedArtifactRequest, ...grpc.CallOption) *gen.PushedArtifact); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.PushedArtifact)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetPushedArtifactRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRelease provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetRelease(ctx context.Context, in *gen.GetReleaseRequest, opts ...grpc.CallOption) (*gen.Release, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.Release
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetReleaseRequest, ...grpc.CallOption) *gen.Release); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.Release)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetReleaseRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRunner provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetRunner(ctx context.Context, in *gen.GetRunnerRequest, opts ...grpc.CallOption) (*gen.Runner, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.Runner
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetRunnerRequest, ...grpc.CallOption) *gen.Runner); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.Runner)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetRunnerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetServerConfig provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetServerConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*gen.GetServerConfigResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetServerConfigResponse
	if rf, ok := ret.Get(0).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) *gen.GetServerConfigResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetServerConfigResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStatusReport provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetStatusReport(ctx context.Context, in *gen.GetStatusReportRequest, opts ...grpc.CallOption) (*gen.StatusReport, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.StatusReport
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetStatusReportRequest, ...grpc.CallOption) *gen.StatusReport); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.StatusReport)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetStatusReportRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTFCRunStatus provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetTFCRunStatus(ctx context.Context, in *gen.GetTFCRunStatusRequest, opts ...grpc.CallOption) (*gen.GetTFCRunStatusResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetTFCRunStatusResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetTFCRunStatusRequest, ...grpc.CallOption) *gen.GetTFCRunStatusResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetTFCRunStatusResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetTFCRunStatusRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTask provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetTask(ctx context.Context, in *gen.GetTaskRequest, opts ...grpc.CallOption) (*gen.GetTaskResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetTaskResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetTaskRequest, ...grpc.CallOption) *gen.GetTaskResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetTaskResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetTaskRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTrigger provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetTrigger(ctx context.Context, in *gen.GetTriggerRequest, opts ...grpc.CallOption) (*gen.GetTriggerResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetTriggerResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetTriggerRequest, ...grpc.CallOption) *gen.GetTriggerResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetTriggerResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetTriggerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUser provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetUser(ctx context.Context, in *gen.GetUserRequest, opts ...grpc.CallOption) (*gen.GetUserResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetUserResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetUserRequest, ...grpc.CallOption) *gen.GetUserResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetUserResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetUserRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVersionInfo provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetVersionInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*gen.GetVersionInfoResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetVersionInfoResponse
	if rf, ok := ret.Get(0).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) *gen.GetVersionInfoResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetVersionInfoResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkspace provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) GetWorkspace(ctx context.Context, in *gen.GetWorkspaceRequest, opts ...grpc.CallOption) (*gen.GetWorkspaceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.GetWorkspaceResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.GetWorkspaceRequest, ...grpc.CallOption) *gen.GetWorkspaceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.GetWorkspaceResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.GetWorkspaceRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAuthMethods provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListAuthMethods(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*gen.ListAuthMethodsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListAuthMethodsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) *gen.ListAuthMethodsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListAuthMethodsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBuilds provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListBuilds(ctx context.Context, in *gen.ListBuildsRequest, opts ...grpc.CallOption) (*gen.ListBuildsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListBuildsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListBuildsRequest, ...grpc.CallOption) *gen.ListBuildsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListBuildsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListBuildsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDeployments provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListDeployments(ctx context.Context, in *gen.ListDeploymentsRequest, opts ...grpc.CallOption) (*gen.ListDeploymentsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListDeploymentsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListDeploymentsRequest, ...grpc.CallOption) *gen.ListDeploymentsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListDeploymentsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListDeploymentsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListHostnames provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListHostnames(ctx context.Context, in *gen.ListHostnamesRequest, opts ...grpc.CallOption) (*gen.ListHostnamesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListHostnamesResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListHostnamesRequest, ...grpc.CallOption) *gen.ListHostnamesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListHostnamesResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListHostnamesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListInstances provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListInstances(ctx context.Context, in *gen.ListInstancesRequest, opts ...grpc.CallOption) (*gen.ListInstancesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListInstancesResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListInstancesRequest, ...grpc.CallOption) *gen.ListInstancesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListInstancesResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListInstancesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListJobs provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListJobs(ctx context.Context, in *gen.ListJobsRequest, opts ...grpc.CallOption) (*gen.ListJobsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListJobsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListJobsRequest, ...grpc.CallOption) *gen.ListJobsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListJobsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListJobsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListOIDCAuthMethods provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListOIDCAuthMethods(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*gen.ListOIDCAuthMethodsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListOIDCAuthMethodsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) *gen.ListOIDCAuthMethodsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListOIDCAuthMethodsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListOnDemandRunnerConfigs provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListOnDemandRunnerConfigs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*gen.ListOnDemandRunnerConfigsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListOnDemandRunnerConfigsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) *gen.ListOnDemandRunnerConfigsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListOnDemandRunnerConfigsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPipelineRuns provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListPipelineRuns(ctx context.Context, in *gen.ListPipelineRunsRequest, opts ...grpc.CallOption) (*gen.ListPipelineRunsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListPipelineRunsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListPipelineRunsRequest, ...grpc.CallOption) *gen.ListPipelineRunsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListPipelineRunsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListPipelineRunsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPipelines provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListPipelines(ctx context.Context, in *gen.ListPipelinesRequest, opts ...grpc.CallOption) (*gen.ListPipelinesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListPipelinesResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListPipelinesRequest, ...grpc.CallOption) *gen.ListPipelinesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListPipelinesResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListPipelinesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProjectTemplates provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListProjectTemplates(ctx context.Context, in *gen.ListProjectTemplatesRequest, opts ...grpc.CallOption) (*gen.ListProjectTemplatesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListProjectTemplatesResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListProjectTemplatesRequest, ...grpc.CallOption) *gen.ListProjectTemplatesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListProjectTemplatesResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListProjectTemplatesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProjects provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListProjects(ctx context.Context, in *gen.ListProjectsRequest, opts ...grpc.CallOption) (*gen.ListProjectsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListProjectsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListProjectsRequest, ...grpc.CallOption) *gen.ListProjectsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListProjectsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListProjectsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPushedArtifacts provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListPushedArtifacts(ctx context.Context, in *gen.ListPushedArtifactsRequest, opts ...grpc.CallOption) (*gen.ListPushedArtifactsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListPushedArtifactsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListPushedArtifactsRequest, ...grpc.CallOption) *gen.ListPushedArtifactsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListPushedArtifactsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListPushedArtifactsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReleases provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListReleases(ctx context.Context, in *gen.ListReleasesRequest, opts ...grpc.CallOption) (*gen.ListReleasesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListReleasesResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListReleasesRequest, ...grpc.CallOption) *gen.ListReleasesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListReleasesResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListReleasesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRunners provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListRunners(ctx context.Context, in *gen.ListRunnersRequest, opts ...grpc.CallOption) (*gen.ListRunnersResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListRunnersResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListRunnersRequest, ...grpc.CallOption) *gen.ListRunnersResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListRunnersResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListRunnersRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListStatusReports provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListStatusReports(ctx context.Context, in *gen.ListStatusReportsRequest, opts ...grpc.CallOption) (*gen.ListStatusReportsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListStatusReportsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListStatusReportsRequest, ...grpc.CallOption) *gen.ListStatusReportsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListStatusReportsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListStatusReportsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTask provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListTask(ctx context.Context, in *gen.ListTaskRequest, opts ...grpc.CallOption) (*gen.ListTaskResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListTaskResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListTaskRequest, ...grpc.CallOption) *gen.ListTaskResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListTaskResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListTaskRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTriggers provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListTriggers(ctx context.Context, in *gen.ListTriggerRequest, opts ...grpc.CallOption) (*gen.ListTriggerResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListTriggerResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListTriggerRequest, ...grpc.CallOption) *gen.ListTriggerResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListTriggerResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListTriggerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUsers provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListUsers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*gen.ListUsersResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListUsersResponse
	if rf, ok := ret.Get(0).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) *gen.ListUsersResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListUsersResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorkspaces provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ListWorkspaces(ctx context.Context, in *gen.ListWorkspacesRequest, opts ...grpc.CallOption) (*gen.ListWorkspacesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ListWorkspacesResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ListWorkspacesRequest, ...grpc.CallOption) *gen.ListWorkspacesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ListWorkspacesResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ListWorkspacesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NoAuthRunTrigger provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) NoAuthRunTrigger(ctx context.Context, in *gen.RunTriggerRequest, opts ...grpc.CallOption) (*gen.RunTriggerResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.RunTriggerResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.RunTriggerRequest, ...grpc.CallOption) *gen.RunTriggerResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.RunTriggerResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.RunTriggerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueueJob provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) QueueJob(ctx context.Context, in *gen.QueueJobRequest, opts ...grpc.CallOption) (*gen.QueueJobResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.QueueJobResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.QueueJobRequest, ...grpc.CallOption) *gen.QueueJobResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.QueueJobResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.QueueJobRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreSnapshot provides a mock function with given fields: ctx, opts
func (_m *WaypointClient) RestoreSnapshot(ctx context.Context, opts ...grpc.CallOption) (gen.Waypoint_RestoreSnapshotClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 gen.Waypoint_RestoreSnapshotClient
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) gen.Waypoint_RestoreSnapshotClient); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Waypoint_RestoreSnapshotClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunPipeline provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) RunPipeline(ctx context.Context, in *gen.RunPipelineRequest, opts ...grpc.CallOption) (*gen.RunPipelineResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.RunPipelineResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.RunPipelineRequest, ...grpc.CallOption) *gen.RunPipelineResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.RunPipelineResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.RunPipelineRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunTrigger provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) RunTrigger(ctx context.Context, in *gen.RunTriggerRequest, opts ...grpc.CallOption) (*gen.RunTriggerResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.RunTriggerResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.RunTriggerRequest, ...grpc.CallOption) *gen.RunTriggerResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.RunTriggerResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.RunTriggerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunnerConfig provides a mock function with given fields: ctx, opts
func (_m *WaypointClient) RunnerConfig(ctx context.Context, opts ...grpc.CallOption) (gen.Waypoint_RunnerConfigClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 gen.Waypoint_RunnerConfigClient
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) gen.Waypoint_RunnerConfigClient); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Waypoint_RunnerConfigClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunnerGetDeploymentConfig provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) RunnerGetDeploymentConfig(ctx context.Context, in *gen.RunnerGetDeploymentConfigRequest, opts ...grpc.CallOption) (*gen.RunnerGetDeploymentConfigResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.RunnerGetDeploymentConfigResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.RunnerGetDeploymentConfigRequest, ...grpc.CallOption) *gen.RunnerGetDeploymentConfigResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.RunnerGetDeploymentConfigResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.RunnerGetDeploymentConfigRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunnerJobStream provides a mock function with given fields: ctx, opts
func (_m *WaypointClient) RunnerJobStream(ctx context.Context, opts ...grpc.CallOption) (gen.Waypoint_RunnerJobStreamClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 gen.Waypoint_RunnerJobStreamClient
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) gen.Waypoint_RunnerJobStreamClient); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Waypoint_RunnerJobStreamClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunnerToken provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) RunnerToken(ctx context.Context, in *gen.RunnerTokenRequest, opts ...grpc.CallOption) (*gen.RunnerTokenResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.RunnerTokenResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.RunnerTokenRequest, ...grpc.CallOption) *gen.RunnerTokenResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.RunnerTokenResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.RunnerTokenRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetConfig provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) SetConfig(ctx context.Context, in *gen.ConfigSetRequest, opts ...grpc.CallOption) (*gen.ConfigSetResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ConfigSetResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ConfigSetRequest, ...grpc.CallOption) *gen.ConfigSetResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ConfigSetResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ConfigSetRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetConfigSource provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) SetConfigSource(ctx context.Context, in *gen.SetConfigSourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *gen.SetConfigSourceRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.SetConfigSourceRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetServerConfig provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) SetServerConfig(ctx context.Context, in *gen.SetServerConfigRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *gen.SetServerConfigRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.SetServerConfigRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartExecStream provides a mock function with given fields: ctx, opts
func (_m *WaypointClient) StartExecStream(ctx context.Context, opts ...grpc.CallOption) (gen.Waypoint_StartExecStreamClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 gen.Waypoint_StartExecStreamClient
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) gen.Waypoint_StartExecStreamClient); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gen.Waypoint_StartExecStreamClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UI_GetDeployment provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UI_GetDeployment(ctx context.Context, in *gen.UI_GetDeploymentRequest, opts ...grpc.CallOption) (*gen.UI_GetDeploymentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UI_GetDeploymentResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UI_GetDeploymentRequest, ...grpc.CallOption) *gen.UI_GetDeploymentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UI_GetDeploymentResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UI_GetDeploymentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UI_GetProject provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UI_GetProject(ctx context.Context, in *gen.UI_GetProjectRequest, opts ...grpc.CallOption) (*gen.UI_GetProjectResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UI_GetProjectResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UI_GetProjectRequest, ...grpc.CallOption) *gen.UI_GetProjectResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UI_GetProjectResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UI_GetProjectRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UI_ListDeployments provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UI_ListDeployments(ctx context.Context, in *gen.UI_ListDeploymentsRequest, opts ...grpc.CallOption) (*gen.UI_ListDeploymentsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UI_ListDeploymentsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UI_ListDeploymentsRequest, ...grpc.CallOption) *gen.UI_ListDeploymentsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UI_ListDeploymentsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UI_ListDeploymentsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UI_ListEventSchemas provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UI_ListEventSchemas(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*gen.UI_ListEventSchemasResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UI_ListEventSchemasResponse
	if rf, ok := ret.Get(0).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) *gen.UI_ListEventSchemasResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UI_ListEventSchemasResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *emptypb.Empty, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UI_ListEvents provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UI_ListEvents(ctx context.Context, in *gen.UI_ListEventsRequest, opts ...grpc.CallOption) (*gen.UI_ListEventsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UI_ListEventsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UI_ListEventsRequest, ...grpc.CallOption) *gen.UI_ListEventsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UI_ListEventsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UI_ListEventsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UI_ListPipelineRuns provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UI_ListPipelineRuns(ctx context.Context, in *gen.UI_ListPipelineRunsRequest, opts ...grpc.CallOption) (*gen.UI_ListPipelineRunsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UI_ListPipelineRunsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UI_ListPipelineRunsRequest, ...grpc.CallOption) *gen.UI_ListPipelineRunsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UI_ListPipelineRunsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UI_ListPipelineRunsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UI_ListPipelines provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UI_ListPipelines(ctx context.Context, in *gen.UI_ListPipelinesRequest, opts ...grpc.CallOption) (*gen.UI_ListPipelinesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UI_ListPipelinesResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UI_ListPipelinesRequest, ...grpc.CallOption) *gen.UI_ListPipelinesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UI_ListPipelinesResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UI_ListPipelinesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UI_ListProjects provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UI_ListProjects(ctx context.Context, in *gen.UI_ListProjectsRequest, opts ...grpc.CallOption) (*gen.UI_ListProjectsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UI_ListProjectsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UI_ListProjectsRequest, ...grpc.CallOption) *gen.UI_ListProjectsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UI_ListProjectsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UI_ListProjectsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UI_ListReleases provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UI_ListReleases(ctx context.Context, in *gen.UI_ListReleasesRequest, opts ...grpc.CallOption) (*gen.UI_ListReleasesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UI_ListReleasesResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UI_ListReleasesRequest, ...grpc.CallOption) *gen.UI_ListReleasesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UI_ListReleasesResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UI_ListReleasesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateProjectTemplate provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UpdateProjectTemplate(ctx context.Context, in *gen.UpdateProjectTemplateRequest, opts ...grpc.CallOption) (*gen.UpdateProjectTemplateResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UpdateProjectTemplateResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UpdateProjectTemplateRequest, ...grpc.CallOption) *gen.UpdateProjectTemplateResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UpdateProjectTemplateResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UpdateProjectTemplateRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateUser provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UpdateUser(ctx context.Context, in *gen.UpdateUserRequest, opts ...grpc.CallOption) (*gen.UpdateUserResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UpdateUserResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UpdateUserRequest, ...grpc.CallOption) *gen.UpdateUserResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UpdateUserResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UpdateUserRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertApplication provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UpsertApplication(ctx context.Context, in *gen.UpsertApplicationRequest, opts ...grpc.CallOption) (*gen.UpsertApplicationResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UpsertApplicationResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UpsertApplicationRequest, ...grpc.CallOption) *gen.UpsertApplicationResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UpsertApplicationResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UpsertApplicationRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertAuthMethod provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UpsertAuthMethod(ctx context.Context, in *gen.UpsertAuthMethodRequest, opts ...grpc.CallOption) (*gen.UpsertAuthMethodResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UpsertAuthMethodResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UpsertAuthMethodRequest, ...grpc.CallOption) *gen.UpsertAuthMethodResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UpsertAuthMethodResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UpsertAuthMethodRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertBuild provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UpsertBuild(ctx context.Context, in *gen.UpsertBuildRequest, opts ...grpc.CallOption) (*gen.UpsertBuildResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UpsertBuildResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UpsertBuildRequest, ...grpc.CallOption) *gen.UpsertBuildResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UpsertBuildResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UpsertBuildRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertDeployment provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UpsertDeployment(ctx context.Context, in *gen.UpsertDeploymentRequest, opts ...grpc.CallOption) (*gen.UpsertDeploymentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UpsertDeploymentResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UpsertDeploymentRequest, ...grpc.CallOption) *gen.UpsertDeploymentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UpsertDeploymentResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UpsertDeploymentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertOnDemandRunnerConfig provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UpsertOnDemandRunnerConfig(ctx context.Context, in *gen.UpsertOnDemandRunnerConfigRequest, opts ...grpc.CallOption) (*gen.UpsertOnDemandRunnerConfigResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UpsertOnDemandRunnerConfigResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UpsertOnDemandRunnerConfigRequest, ...grpc.CallOption) *gen.UpsertOnDemandRunnerConfigResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UpsertOnDemandRunnerConfigResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UpsertOnDemandRunnerConfigRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertPipeline provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UpsertPipeline(ctx context.Context, in *gen.UpsertPipelineRequest, opts ...grpc.CallOption) (*gen.UpsertPipelineResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UpsertPipelineResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UpsertPipelineRequest, ...grpc.CallOption) *gen.UpsertPipelineResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UpsertPipelineResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UpsertPipelineRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertProject provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UpsertProject(ctx context.Context, in *gen.UpsertProjectRequest, opts ...grpc.CallOption) (*gen.UpsertProjectResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UpsertProjectResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UpsertProjectRequest, ...grpc.CallOption) *gen.UpsertProjectResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UpsertProjectResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UpsertProjectRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertPushedArtifact provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UpsertPushedArtifact(ctx context.Context, in *gen.UpsertPushedArtifactRequest, opts ...grpc.CallOption) (*gen.UpsertPushedArtifactResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UpsertPushedArtifactResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UpsertPushedArtifactRequest, ...grpc.CallOption) *gen.UpsertPushedArtifactResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UpsertPushedArtifactResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UpsertPushedArtifactRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertRelease provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UpsertRelease(ctx context.Context, in *gen.UpsertReleaseRequest, opts ...grpc.CallOption) (*gen.UpsertReleaseResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UpsertReleaseResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UpsertReleaseRequest, ...grpc.CallOption) *gen.UpsertReleaseResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UpsertReleaseResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UpsertReleaseRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertStatusReport provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UpsertStatusReport(ctx context.Context, in *gen.UpsertStatusReportRequest, opts ...grpc.CallOption) (*gen.UpsertStatusReportResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UpsertStatusReportResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UpsertStatusReportRequest, ...grpc.CallOption) *gen.UpsertStatusReportResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UpsertStatusReportResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UpsertStatusReportRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertTrigger provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UpsertTrigger(ctx context.Context, in *gen.UpsertTriggerRequest, opts ...grpc.CallOption) (*gen.UpsertTriggerResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UpsertTriggerResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UpsertTriggerRequest, ...grpc.CallOption) *gen.UpsertTriggerResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UpsertTriggerResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UpsertTriggerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertWorkspace provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) UpsertWorkspace(ctx context.Context, in *gen.UpsertWorkspaceRequest, opts ...grpc.CallOption) (*gen.UpsertWorkspaceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.UpsertWorkspaceResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.UpsertWorkspaceRequest, ...grpc.CallOption) *gen.UpsertWorkspaceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.UpsertWorkspaceResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.UpsertWorkspaceRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidateJob provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) ValidateJob(ctx context.Context, in *gen.ValidateJobRequest, opts ...grpc.CallOption) (*gen.ValidateJobResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.ValidateJobResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.ValidateJobRequest, ...grpc.CallOption) *gen.ValidateJobResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.ValidateJobResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.ValidateJobRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WaypointHclFmt provides a mock function with given fields: ctx, in, opts
func (_m *WaypointClient) WaypointHclFmt(ctx context.Context, in *gen.WaypointHclFmtRequest, opts ...grpc.CallOption) (*gen.WaypointHclFmtResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gen.WaypointHclFmtResponse
	if rf, ok := ret.Get(0).(func(context.Context, *gen.WaypointHclFmtRequest, ...grpc.CallOption) *gen.WaypointHclFmtResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gen.WaypointHclFmtResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *gen.WaypointHclFmtRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewWaypointClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewWaypointClient creates a new instance of WaypointClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewWaypointClient(t mockConstructorTestingTNewWaypointClient) *WaypointClient {
	mock := &WaypointClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
