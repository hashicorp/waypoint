---
layout: docs
page_title: 'Lifecycle: Build'
sidebar_title: Build
description: |-
  Waypoint build lifecycle documentation
---

# Build

A **build** takes application source and converts it to an _artifact_.

An artifact is the packaged form of an application required for deployment on
your target platform: a container image, VM image, or maybe a simple zip file.
The build process may also include an optional **push** operation to push
the built artifact to a registry so that it is available for the deployment
platform.

A build is triggered during a `waypoint up` or using the dedicated
`waypoint build` command.

## Configuration

The build is configured using the `build` stanza within an `app` stanza:

```hcl
app "my-app" {
  build {
    use "docker" {}
  }
}
```

### Build Methods

Waypoint includes these builtin plugins to build a Docker image for your app.

- [Docker Build](/plugins/docker#docker-builder)
- Docker Pull Build
- [Cloud Native Buildpacks](/plugins/pack)

You can also create a [plugin](/plugins) to extend Waypoint with your own builder.

### Choosing How to Build Your App

#### Docker Build

**Example configuration**

```hcl
app "my-app" {
  build {
    use "docker" {}
  }
}
```

The Docker plugin leverages the application `Dockerfile` to create a container
image. If you application works with the `docker build`
[Docker command](https://docs.docker.com/engine/reference/commandline/build/)
it should work well the Waypoint Docker plugin.

[Learn how to use Docker Build in your app](/plugins/docker)

#### Docker Pull Build

**Example configuration**

```hcl
app "my-app" {
  build {
    use "docker-pull" {
      image = "hashicorp/http-echo"
      tag   = "latest"
    }
  }
  deploy {
    use "docker" {
      command = ["-listen", ":3000","-text", "hello"]
    }
  }
}
```

The Docker Pull plugin is ideal when you prefer to use an existing Docker image as-is without rebuilding it.
This plugin performs a `docker pull`. The plugin injects the Waypoint Entrypoint by default, which can be disabled.

#### Cloud Native Buildpacks

**Example configuration**

```hcl
app "my-app" {
  build {
    use "pack" {}
  }
}
```

[Cloud Native Buildpacks](https://buildpacks.io/) are a fast way to get started
creating a containerized application without writing a `Dockerfile`. Buildpacks
take application source and build a container for you if there are matching
buildpacks. The "pack" plugin defaults to Heroku Buildpacks with a builder image
located on Docker Hub at
[heroku/buildpacks:18](https://hub.docker.com/r/heroku/buildpacks/tags).

#### Configuring an Alternative Buildpack Provider

| Provider              | Builder Image                 |
|-----------------------|-------------------------------|
| Heroku                | heroku/buildpacks:18          |
| Cloud Foundry Paketo  | paketobuildpacks/builder:base |
| Google Cloud Platform | gcr.io/buildpacks/builder:v1  |

Several `waypoint.hcl` adjustments may be required to enable alternative builders.

1. The `builder` variable of the `pack` build plugin should explicitly specify the buildpacks builder image like `paketobuildpacks/builder:base`.
1. The `service_port` variable of the deploy plugin must match the buildpacks port. Paketo buildpacks commonly use `8080` and the default Waypoint `service_port` is `3000`.

Paketo buildpacks example `waypoint.hcl`:

```hcl
project = "example-java"

app "example-java" {
    build {
        use "pack" {
            builder="paketobuildpacks/builder:base"
        }
    }
    deploy {
        use "docker" {
            service_port=8080
        }
    }
}
```

GCP buildpacks example `waypoint.hcl`:

```hcl
project = "example-java"

app "example-java" {
    build {
        use "pack" {
            builder="gcr.io/buildpacks/builder:v1"
        }
    }
    deploy {
        use "docker" {}
    }
}
```

#### Buildpack Troubleshooting

If you have a problem using Cloud Native Buildpacks, try using the `pack` CLI
directly with Docker
[similar to this example](https://buildpacks.io/docs/app-journey/).

## Registry

A build may optionally specify a registry to push the built artifact to.
This is sometimes required so that the build artifact is accessible to the
deployment platform.

If a registry is specified, the deployment step will use the artifact
in the registry. If a registry is not specified, the deployment step will
use the artifact that is the result of the build.

### Situations for a Registry

**An example of a situation requiring a registry:** Kubernetes deployments
need access to the Docker image that is built, but a Docker build process often
produces a local Docker image. The registry configuration is used to push
the locally built Docker image to the remote registry.

**An example of a situation that does not require a registry:** AMIs (Amazon
Machine Images) are registered directly with Amazon and are never local
artifacts. Therefore, a separate registry configuration is not required since
the build/registry phases are one and the same.
